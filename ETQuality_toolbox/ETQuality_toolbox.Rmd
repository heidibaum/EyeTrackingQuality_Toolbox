---
title: "Eye Tracking Quality Toolbox"
author: "Heidi Baumgartner"
date: "6/2/2017"
output:
  html_document:
    toc: yes
    toc_depth: 2
    toc_float: yes
  html_notebook:
    toc: yes
    toc_depth: 2
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: '2'
---

> written by Heidi Baumgartner and Rachel Martino at the [Developmental Cognitive Neuroscience Lab](http://research.clps.brown.edu/dcnl/) at Brown University, directed by Dr. Dima Amso  
![Caption](NotebookFigures/DCNL.png)  

```{r libraries, include=FALSE}
## clear workspace to avoid interference from previous runs
rm(list=ls())

## load libraries (might have to install libraries if first time using)
library(ggplot2)
library(data.table)
library(rmarkdown)
library(tictoc)
library(knitr)
```


# Overview

Some eye-tracking (ET) systems collect independent data streams from each eye (left and right), but analysis protocols often require the user to choose one eye or the other for analysis purposes. In optimal circumstances, it makes little difference which eye is used because these data streams are nearly identical. Sometimes, however, the data stream from one eye is significantly more stable or accurate than the stream from the other eye (*e.g.*, this situation occurs often when tracking very young participants with a between-eye distance that is at the lower limit of what the eye tracker can handle). 

This toolbox is designed to quantify the **TRACKING RATIO** (percent of ET samples with non-zero gaze coordinates) and calibration **ACCURACY** (deviation of estimated point-of-regard from defined coordinates) by eye (R/L) for eye tracking data and to **RECOMMEND** which eye to use for subsequent analyses based on these metrics. The toolbox also generates a **PRECISION** metric (modeled after [Wass et al., 2014](https://onlinelibrary.wiley.com/doi/full/10.1111/infa.12055)), which indicates the amount of sample-to-sample jitter or noise that is present in the data for each eye. This metric is currently used for visualization purposes only, and is not included in the recommendation decision. 

The toolbox is designed to work with data generated by BeGaze (SensoMotoric Instruments), but should work as long as the variables/format specified in [Using a non-SMI system](#using-a-non-smi-system) are present. 

*** 

# Instructions

Refer to the ET Quality Toolbox USER GUIDE for instructions on using the toolbox to generate quality metrics and eye recommendations.

***

# Set parameters

**These are the experiment-specific parameters that must be defined by the user.**  
*Once these parameters have been set, you should not have to edit code in other sections beyond tinkering with plot sizing.*

1. Update ***datadir*** to reflect correct path to data and ***outputname*** with desired name of summary output file  
    + **IMPORTANT:** Make sure that the *only* .txt file(s) in the directory specified by *datadir* is raw gaze data in the format specified above, because the toolbox will attempt to load/append all .txt files in *datadir*. Any files not in this format will cause the toolbox to break.
```{r param_path, echo=TRUE}
## path to data directory
datadir <- "/Users/heidibaumgartner/Documents/GitHub/EyeTrackingQuality_Toolbox/ETQuality_toolbox/ExampleExpt_Data"

## file name for summary metrics
outputname <- "ExampleExp_ETQuality_output.csv"
```
<br>

2. Define ET system parameter(s). This value is used to determine the duration (in ms) of each sample.   
```{r param_ET, echo=TRUE}
## sampling rate of eye tracker (Hz)
EyeTrackHz <- 60
```
<br>

3. **Set thresholds** for 'meaningful' differences (*i.e.*, discrepancies that are big enough to care about and  therefore should be used for eye choice determination) for the following metrics:
    + **Tracking ratio** (***Threshold_TrackingDiff***): default difference threshold is 5% (*i.e.*, only use tracking ratio for eye choice recommendation if TR for one eye is >5% better than TR for other eye)
    + **Validation accuracy** (***Threshold_AccuracyDiff***): default difference threshold is 25 pixels (*i.e.*, only use validation deviation values for eye choice recommendation if deviation values for one eye are >25 pixels closer to validation-stimulus center than deviation values for other eye)
    + **Precision** (***Threshold_PrecisionDiff***:  
```{r param_thresholds, echo=TRUE}
## threshold for meaningful tracking ratio difference (%)
Threshold_TrackingDiff <- 5 # %

## threshold for meaningful deviation difference (pixels)
Threshold_AccuracyDiff <- 25  # pixels 

## threshold for meaningful precision difference 
Threshold_PrecisionDiff <- 1   
```
<br>

4. Define stimuli to be used for validation purposes (***ValidationStim***), AOIs (***ValidataionAOI***), and stimulus coordinates (***ValidationX/Y***)
    + Make sure that these four lists all have the same number of items 
    + If using the DCNL custom validation block, use default values  
    + Stimulus names in *ValidationStim* must match text in *Stimulus* column of data file(s) EXACTLY (case-sensitive)
    + AOI names in *ValidationAOI* must match text in *AOI Name Left/Right* columns of data files EXACTLY (case-sensitive)
```{r param_val, echo=TRUE}
## define names of stimuli used to measure validation accuracy (case-sensitive)
ValidationStim <- c('validation1.jpg',
                    'validation2.jpg',
                    'validation3.jpg',
                    'validation4.jpg')

## AOIs for corresponding items in 'ValidationStim' (case-sensitive)
ValidationAOI <- c('validation1',
                   'validation2',
                   'validation3',
                   'validation4')  

## X coordinates for center of corresponding items in 'ValidationStim'
ValidationX <- c(480, 
                 1440, 
                 480, 
                 1440) 

## Y coordinates for center of corresponding items in 'ValidationStim'
ValidationY <- c(270, 
                 270, 
                 810, 
                 810) 
```
<br>
    
5. Define experimental stimuli (***ExperimentalStim***) that you want to <U>INCLUDE</U> in tracking ratio and distance calculations 
    + To define non-experimental stimuli to <U>EXCLUDE</U> from these calculations instead, COMMENT OUT ***ExperimentalStim***  definition and use/edit ***FillerStim*** instead. 
    + If you want to <U>include all stimuli</U> in tracking ratio/distance calculations, comment out ***ExperimentalStim*** and use ***FillerStim <- c('nothing')***
```{r param_exp, echo=TRUE}
## define stimulus names to be INCLUDED in tracking ratio/distance calculations 
ExperimentalStim <- c('Pic1.jpg', 'Pic2.jpg', 'Pic3.jpg', 'Movie1.avi', 'Movie2.avi')

## define filler stimulus names to be EXCLUDED from tracking ratio/distance calculations
# FillerStim <- c('Validation.jpg', 'validation1.jpg', 'validation2.jpg', 'validation3.jpg', 'validation4.jpg', 'Fixation.png')

## to include ALL stimuli in tracking ratio/distance calculations, use this instead
# FillerStim <- c('nothing')
```
<br>

6. Choose if you want to save plots to individual files (***saveplotstofile***) and edit plot aesthetics (*e.g.*, color, marker shape) (optional)
```{r param_plots, echo=TRUE}
## save plots as individual files?
saveplotstofile <- 1 # 0=no, 1=yes 

## Aesthetics for plots (can change as desired)
marker_colors <- c('#007c92', '#e98300', '#8c1515','#8c1515') 
marker_fills <- c('#007c92', NA, NA, NA) # NA for no fill
marker_shapes <- c(21,21,4,4) # 21=circle, 22=square, 23=diamond, 24=triangle, 25=invertedtriangle, 4=X
marker_size <- 2    # size of markers on point plots
marker_stroke <- 2  # width of marker stroke on point plots
legend_size <- 3    # size of markers in plot legends
title_color <-  '#8c1515' 
title_size <- 16    # font size of plot titles
yaxis_size <- 12     # font size of y-axis titles
line_colors <- c('#68a2c1','#0a8002','808080')

## grayscale color options
# marker_colors <- c('gray', 'black', 'black', 'black')
# marker_fills <- c('gray', NA, NA, NA)
# title_color <- 'black'
```
<br>

7. Choose if you want to run the supplementary [Precision](#supplementary-feature-precision) section (*This section takes a very long time to run with large amounts of data*) 
```{r param_prec, echo=TRUE}
## to include Precision chunks, prec_on = TRUE
## to exclude Precision chunks, prec_on = FALSE
prec_on = TRUE 
```

<br>
<br>

***

# Load and organize data

[You shouldn't need to change anything here unless you are using data generated outside of BeGaze and need to adjust for different variable names in data file(s).]

```{r loaddata, echo = FALSE, warning=FALSE}
## This chunk loads data and organizes variable names

## calcuate sample duration based on ET sampling rate
SampleDuration <- 1000/EyeTrackHz

## create subdirectory in datadir to save plots
outpath <- file.path(datadir,"ETQtoolbox_output")
dir.create(outpath)
figpath <- paste(outpath,"/",sep="")

## identify all text files in data directory
setwd(datadir)
files = list.files(path=datadir, pattern="*.txt")

## load in data files and bind into single data table
DT_full = rbindlist(lapply(files, fread))

## rename variables as needed
names(DT_full)[names(DT_full) == 'Participant'] <- 'Subject'
names(DT_full)[names(DT_full) == 'RecordingTime [ms]'] <- 'Time'
names(DT_full)[names(DT_full) == 'Point of Regard Right X [px]'] <- 'RPOR_X'
names(DT_full)[names(DT_full) == 'Point of Regard Right Y [px]'] <- 'RPOR_Y'
names(DT_full)[names(DT_full) == 'Point of Regard Left X [px]'] <- 'LPOR_X'
names(DT_full)[names(DT_full) == 'Point of Regard Left Y [px]'] <- 'LPOR_Y'
names(DT_full)[names(DT_full) == 'AOI Name Right'] <- 'AOI_R'
names(DT_full)[names(DT_full) == 'AOI Name Left'] <- 'AOI_L'
names(DT_full)[names(DT_full) == 'Eye Position Right X [mm]'] <- 'REyePos_X'
names(DT_full)[names(DT_full) == 'Eye Position Right Y [mm]'] <- 'REyePos_Y'
names(DT_full)[names(DT_full) == 'Eye Position Right Z [mm]'] <- 'REyePos_Z'
names(DT_full)[names(DT_full) == 'Eye Position Left X [mm]'] <- 'LEyePos_X'
names(DT_full)[names(DT_full) == 'Eye Position Left Y [mm]'] <- 'LEyePos_Y'
names(DT_full)[names(DT_full) == 'Eye Position Left Z [mm]'] <- 'LEyePos_Z'
names(DT_full)[names(DT_full) == 'Index Right'] <- 'FixIndex_R'
names(DT_full)[names(DT_full) == 'Index Left'] <- 'FixIndex_L'

nsubjects <- length(unique(DT_full$Subject)) # identify number of subjects
DT_full <- DT_full[order(Subject,Time)] # sort table by subject then time
DT_full$Time_diff <- c(0, diff(DT_full$Time)) # calculate time difference between samples

## replace extreme values with average time value (these happen mostly at subject boundaries but occasionally at other times as well)
DT_full$Time_diff[DT_full$Time_diff > 100] <- 16.7 
DT_full$Time_diff[DT_full$Time_diff <= 0] <- 16.7

## determine sampling interval between data points (SMI sometimes doesn't output data every sample if no gaze detected)
DT_full$SampleInterval <- round(DT_full$Time_diff/SampleDuration,0)
## add count variable of samples
DT_full <- DT_full[, SampleNum := cumsum(SampleInterval), by=list(Subject)]

```
<br>
<br>

***

# Tracking ratio 

Tracking Ratio is calculated by dividing the number of samples with non-0 gaze data (*TrackedSamples*) by total number of samples for the subset of stimuli defined above (either for stimuli defined in *ExperimentalStim* list or for all stimuli other than those defined in *FillerStim* list), then multiplied by 100 to convert to percentage.

\[
  TR = (\frac{TrackedSamples}{TotalSamples}) * 100
\]

```{r tr, echo = FALSE}
## create subset with only stimulus/stimuli you want to include in quantity/distance metrics (defined above) 
if(exists("ExperimentalStim")) { # if ExperimentalStim was defined
  DT_stimuli <- subset(DT_full, Stimulus %in% ExperimentalStim) 
} else { # if no ExperimentalStim definition, use FillerStim to exclude stimuli instead
  DT_stimuli <- subset(DT_full, !(Stimulus %in% FillerStim)) 
}

## determine number of unique experimental stimuli and max number of trials
nstim_exp <- length(unique(DT_stimuli$Stimulus))
ntrial_exp <- length(unique(DT_stimuli$Trial))

## initialize "Tracking" variables for each eye 
## (binary variable indicating if eye (L or R) provided non-zero gaze data on that sample)
DT_stimuli$TrackingR <- 0
DT_stimuli$TrackingL <- 0

## if X and Y coordinates are both not equal to 0, set tracking variable to 1
DT_stimuli$TrackingR[DT_stimuli$RPOR_X != 0 & DT_stimuli$RPOR_Y != 0] <- 1 
DT_stimuli$TrackingL[DT_stimuli$LPOR_X != 0 & DT_stimuli$LPOR_Y != 0] <- 1 

## get overall tracking ratios for each eye by subject
DT_tracking <- DT_stimuli[, .(TrackingRatio_R = round(mean(TrackingR)*100),
                              TrackingRatio_L = round(mean(TrackingL)*100),
                              NSamples_R = sum(TrackingR),
                              NSamples_L = sum(TrackingL),
                              TotalSamples = length(Time)),
                          by=.(Subject)]

## get tracking ratios for each stimulus by subject
DT_tracking_byStim <- DT_stimuli[, .(TrackingRatio_R = round(mean(TrackingR)*100),
                                     TrackingRatio_L = round(mean(TrackingL)*100),
                                     NSamples_R = sum(TrackingR),
                                     NSamples_L = sum(TrackingL),
                                     TotalSamples = length(Time)),
                                 by=.(Subject,Trial,Stimulus)]
```
<br>
<br>

## Table 1: Tracking ratio values and eye comparisons

* *BetterTracking:* Eye with better tracking ratio (difference between eyes not necessarily above threshold!)  
* *TrackingDiff:* Absolute difference of L and R tracking ratios

```{r tr_table, echo = FALSE}
## determine which eye provided more data for each subject
DT_tracking$BetterTracking[DT_tracking$TrackingRatio_L > DT_tracking$TrackingRatio_R] <- "L"
DT_tracking$BetterTracking[DT_tracking$TrackingRatio_L < DT_tracking$TrackingRatio_R] <- "R"
DT_tracking$TrackingDiff <- abs(DT_tracking$TrackingRatio_L - DT_tracking$TrackingRatio_R)

## reorder columns and display table with tracking ratios by subject
setcolorder(DT_tracking, c("Subject", "BetterTracking", "TrackingDiff", "TrackingRatio_L", "TrackingRatio_R", "TotalSamples", "NSamples_L","NSamples_R"))

## display tracking ratio table
DT_tracking 
```
<br>
<br>

## Figure: Tracking ratio (overall)

This plot provides a quick visualization of tracking ratio by eye for each subject. 

```{r tr_melt1, echo = FALSE}
## melt data in long format for plotting
DT_tracking_melt <- DT_tracking[,.(Subject,TrackingRatio_L,TrackingRatio_R)]
names(DT_tracking_melt)[names(DT_tracking_melt) == 'TrackingRatio_L'] <- 'Left'
names(DT_tracking_melt)[names(DT_tracking_melt) == 'TrackingRatio_R'] <- 'Right'
DT_tracking_melt <- melt(DT_tracking_melt, 
                         id.vars=c('Subject'),
                         variable.name='Eye', 
                         value.name='TrackingRatio')
```

```{r tr_fig1, echo = FALSE}
## to control display size of plot, add these parameters to {r} and adjust values.
## fig.width=8, fig.height=8

## plot parameters
figname_tr1 <- file.path(outpath,"TrackingRatio_overall.png")
plottitle <- "Tracking ratio"
xlabel <- " "
ylabel <- "Tracking ratio [%]"
yaxis_min <- 0
yaxis_max <- 100

## generate plot
g <- ggplot(DT_tracking_melt, aes(x=1, y=TrackingRatio, 
                                  ymin=yaxis_min, ymax=yaxis_max,
                                  color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(size=marker_size, stroke=marker_stroke) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top", 
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 
g 

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_tr1, width=4, height=4, units="in", dpi=300)
}
```
<br>
<br>

## Figure: Tracking ratio, by stimulus (all trials)

This plot provides a visualization of tracking ratio by stimulus. This allows you to quickly see if tracking ratio differs or is consistent across stimuli. Each circle represents a single presentation of the stimulus. Data points are jittered so that if stimuli are presented more than once, you will be able to see the tracking ratio during each presentation. 

*NOTE: If stimuli do not repeat (1 trial per stimulus), this figure will be redundant with Figure 1c.*

```{r tr_melt2, echo = FALSE}
## melt data in long format for plotting
DT_tracking_byStim_melt <- DT_tracking_byStim[,.(Subject,Stimulus,TrackingRatio_L,TrackingRatio_R)]
names(DT_tracking_byStim_melt)[names(DT_tracking_byStim_melt) == 'TrackingRatio_L'] <- 'Left'
names(DT_tracking_byStim_melt)[names(DT_tracking_byStim_melt) == 'TrackingRatio_R'] <- 'Right'
DT_tracking_byStim_melt <- melt(DT_tracking_byStim_melt, 
                                id.vars=c('Subject','Stimulus'),
                                variable.name='Eye',
                                value.name='TrackingRatio')
```

```{r tr_fig2, echo = FALSE}

## plot parameters
figname_tr2 <- file.path(outpath,"TrackingRatio_byStim_all.png")
plottitle <- "Tracking ratio, by stimulus\n(all presentations)"
xlabel <- "Stimulus"
ylabel <- "Tracking Ratio [%]"
yaxis_min <- 0
yaxis_max <- 100

## generate plot 
g <- ggplot(DT_tracking_byStim_melt, aes(x=Stimulus, y=TrackingRatio, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_jitter(size=marker_size, stroke=marker_stroke, alpha=1, width=.2) + # jitters points to make multiple trials visible
  scale_size(guide='none') +
  facet_wrap(~ Subject) + # to control number of columns, ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size=yaxis_size),
        legend.position="top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes=list(size=legend_size,stroke=marker_stroke)))
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_tr2, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>


## Figure: Tracking ratio, by stimulus (stimulus averages)

This plot provides a visualization of tracking ratio by stimulus. If stimuli are presented more than once, the data point represents the tracking ratio (by eye) averaged across all presentations of that stimulus.

*NOTE: If stimuli do not repeat (1 trial per stimulus), this figure will be redundant with Figure 1b.*

```{r tr_melt3, echo = FALSE}
## melt data in long format for plotting
DT_tracking_byStim_means <- DT_tracking_byStim_melt[,.(TrackingRatio = mean(TrackingRatio)),
                                                    by=.(Subject,Stimulus,Eye)]
```

```{r tr_fig3, echo = FALSE}

## plot parameters
figname_tr3 <- file.path(outpath,"TrackingRatio_byStim_mean.png")
plottitle <- "Tracking ratio, by stimulus\n(averaged over repeat presentations)"
xlabel <- "Stimulus"
ylabel <- "Tracking Ratio [%]"
yaxis_min <- 0
yaxis_max <- 100

## generate plot
g <- ggplot(DT_tracking_byStim_means, aes(x=Stimulus, y=TrackingRatio, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(size=marker_size, stroke=marker_stroke) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) + 
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x = element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_tr3, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>


## Figure: Tracking ratio, by trial

This plot provides a visualization of tracking ratio by trial. This allows you to quickly see if a subject's tracking ratio is consistent or changes over time. 

```{r tr_melt4, echo = FALSE}
## melt data in long format for plotting
DT_tracking_byTrial_melt <- DT_tracking_byStim[,.(Subject,Trial,TrackingRatio_L,TrackingRatio_R)]
names(DT_tracking_byTrial_melt)[names(DT_tracking_byTrial_melt) == 'TrackingRatio_L'] <- 'Left'
names(DT_tracking_byTrial_melt)[names(DT_tracking_byTrial_melt) == 'TrackingRatio_R'] <- 'Right'
DT_tracking_byTrial_melt <- melt(DT_tracking_byTrial_melt, 
                                id.vars=c('Subject','Trial'),
                                variable.name='Eye',
                                value.name='TrackingRatio')
```

```{r tr_fig4, echo = FALSE, fig.width=4, fig.height=7}

## plot parameters
figname_tr4 <- file.path(outpath,"TrackingRatio_byTrial.png")
plottitle <- "Tracking ratio, by trial"
xlabel <- "Trial"
ylabel <- "Tracking Ratio [%]"
yaxis_min <- 0
yaxis_max <- 100

## generate plot
g <- ggplot(DT_tracking_byTrial_melt, aes(x=Trial, y=TrackingRatio, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(size=marker_size, stroke=marker_stroke) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject, ncol=1) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) + 
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x = element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 
g

# save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_tr4, width=4, height=7, units="in", dpi=300)
}
```
<br>
<br>


***

# Calibration accuracy

Deviation statistics are calculated using the longest fixation to the validation stimulus on each validation trial (based on the assumption that the longest fixation that falls within the validation AOI on each trial most likely reflects looking to the validation stimulus). The average euclidean distance (deviation) from each point-of-regard (POR) within the longest fixation to the validation stimulus is calculated for each trial. Deviation values are then averaged over all validation trials to generate an average deviation value. 

\begin{aligned}
  Deviation_{sample} &= \sqrt{(STIM_{x}-POR_{x})^2+(STIM_{y}-POR_{y})^2} \\
  \\
  Deviation_{fixation} &= mean(Deviation_{samples}) \\
  \\
  Deviation_{average} &= mean(Deviation_{LongestFixations})
\end{aligned}

```{r dev, echo = FALSE}
## create subset with validation stimuli
DT_validation <- subset(DT_full, Stimulus %in% ValidationStim) # name of validation stimulus

## determine number of unique validation stimuli and max number of validation trials
nstim_val <- length(unique(DT_validation$Stimulus))
ntrial_val <- length(unique(DT_validation$Trial))

## match validation stimulus coordinates with corresponding stimuli
for(i in 1:length(ValidationStim)) {
  DT_validation$StimulusX[DT_validation$Stimulus == ValidationStim[i]] <- ValidationX[i]
  DT_validation$StimulusY[DT_validation$Stimulus == ValidationStim[i]] <- ValidationY[i]
}

## calculate POR deviation from validation stimulus for each eye
DT_validation$Deviation_L <- DT_validation[,.(sqrt((StimulusX-LPOR_X)^2 +
                                                    (StimulusY-LPOR_Y)^2))]
DT_validation$Deviation_R <- DT_validation[,.(sqrt((StimulusX-RPOR_X)^2 +
                                                    (StimulusY-RPOR_Y)^2))]
## only keep distance values for fixations within appropriate AOIs
for(i in 1:length(ValidationStim)) {
  DT_validation$Deviation_L[DT_validation$Stimulus == ValidationStim[i] & DT_validation$AOI_L != ValidationAOI[i]] <- NA
  DT_validation$Deviation_R[DT_validation$Stimulus == ValidationStim[i] & DT_validation$AOI_R != ValidationAOI[i]] <- NA
}

## calculate deviation from center, stdev of deviation, and duration of each fixation by eye
DT_accuracy_L <- DT_validation[,.(Deviation_L = mean(Deviation_L, na.rm=TRUE),
                                  stdev_L = sd(Deviation_L, na.rm=TRUE),
                                  Duration_L = sum(Time_diff)),
                             by = .(Subject,Trial,`Category Left`,FixIndex_L, Stimulus)]
DT_accuracy_R <- DT_validation[,.(Deviation_R = mean(Deviation_R, na.rm=TRUE),
                                  stdev_R = sd(Deviation_R, na.rm=TRUE),
                                  Duration_R = sum(Time_diff)),
                             by = .(Subject,Trial,`Category Right`,FixIndex_R, Stimulus)]

## keep only fixation data (get rid of blinks and saccades)
DT_accuracy_L <- subset(DT_accuracy_L, `Category Left` == "Fixation")
DT_accuracy_R <- subset(DT_accuracy_R, `Category Right` == "Fixation")
## keep only fixations within validation AOI (ie, have a deviation value)
DT_accuracy_L <- subset(DT_accuracy_L, Deviation_L > 0)
DT_accuracy_R <- subset(DT_accuracy_R, Deviation_R > 0)
DT_accuracy_L <- subset(DT_accuracy_L, stdev_L > 0)
DT_accuracy_R <- subset(DT_accuracy_R, stdev_R > 0)

## identify longest fixation to validation AOI on each trial
DT_accuracy_L <- DT_accuracy_L[DT_accuracy_L[, .I[Duration_L == max(Duration_L)],
                                             by=.(Subject,Trial)]$V1]
DT_accuracy_R <- DT_accuracy_R[DT_accuracy_R[, .I[Duration_R == max(Duration_R)],
                                             by=.(Subject,Trial)]$V1]

## average across trials
DT_accuracy_L_means <- DT_accuracy_L[,.(Deviation_L = mean(Deviation_L),
                                        stdev_L = mean(stdev_L),
                                        Duration_L = mean(Duration_L)),
                                     by = Subject]
DT_accuracy_R_means <- DT_accuracy_R[,.(Deviation_R = mean(Deviation_R),
                                        stdev_R = mean(stdev_R),
                                        Duration_R = mean(Duration_R)),
                                     by = Subject]
## merge tables by subject
DT_accuracy_byStim <- merge(DT_accuracy_L,DT_accuracy_R, by=c("Subject","Trial","Stimulus"), all=TRUE)
DT_accuracy <- merge(DT_accuracy_L_means,DT_accuracy_R_means, by="Subject", all=TRUE)

## determine which eye provided more accurate data for each subject
DT_accuracy$BetterAccuracy[DT_accuracy$Deviation_L > DT_accuracy$Deviation_R] <- "R"
DT_accuracy$BetterAccuracy[DT_accuracy$Deviation_L < DT_accuracy$Deviation_R] <- "L"
DT_accuracy$AccuracyDiff <- abs(DT_accuracy$Deviation_L - DT_accuracy$Deviation_R)
```
<br>

## Table: Deviation values

* *BetterAccuracy:* Eye with better (*i.e.*, smaller) deviation value (not necessarily above threshold!)  
* *AccuracyDiff:* Absolute difference of L and R deviation values  
* *stdev_L/R:* Average standard deviation of deviation values within each fixation (higher values indicate less stable fixations)
* *Duration_L/R:* Average fixation duration of fixations used to calculate deviations

```{r dev_table, echo = FALSE}
## reorder columns and display accuracy table
setcolorder(DT_accuracy, c("Subject", "BetterAccuracy", "AccuracyDiff", 
                           setdiff(names(DT_accuracy), c("Subject", "BetterAccuracy","AccuracyDiff"))))

## display table with deviation values
DT_accuracy # display accuracy table
```
<br>
<br>


## Figure: Deviation values

This plot shows average deviation values (*i.e.*, average distance of estimated POR from center of validation stimulus) by eye for each subject. Smaller deviation values indicate a better calibration/more accurate tracking. 

```{r dev_melt1, echo = FALSE}
## melt data in long format for plotting
DT_accuracy_melt <- DT_accuracy[,.(Subject,Deviation_L,Deviation_R)]
names(DT_accuracy_melt)[names(DT_accuracy_melt) == 'Deviation_L'] <- 'Left'
names(DT_accuracy_melt)[names(DT_accuracy_melt) == 'Deviation_R'] <- 'Right'
DT_accuracy_melt <- melt(DT_accuracy_melt, 
                         id.vars=c('Subject'),
                         variable.name='Eye', 
                         value.name='Deviation')
```

```{r dev_fig1, echo = FALSE}

## plot parameters
figname_dev1 <- file.path(outpath,"Deviations_overall.png")
plottitle <- "Average deviation\n(smaller is better!)"
xlabel <- " "
ylabel <- "Deviation [px]"
yaxis_min <- 0
yaxis_max <- max(DT_accuracy_melt$Deviation,na.rm=TRUE) + 10

## generate plot
g <- ggplot(DT_accuracy_melt, aes(x=1, y=Deviation, 
                                  ymin=yaxis_min, ymax=yaxis_max,
                                  color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(size=marker_size, stroke=marker_stroke) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_dev1, width=4, height=4, units="in", dpi=300)
}
```
<br>
<br>


## Figure: Deviation values, by validation stimulus

This plot shows deviation values for each validation stimulus. This allows you to see at a glance if high deviations are due to a generally poor calibration (consistently high values across stimuli) or outlier value(s). It also allows you to see if any participants are missing data for one or more validation stimuli (missing data will result in a displayed warning before the plot).

```{r dev_melt2, echo = FALSE}
## melt data in long format for plotting
DT_accuracy_byStim_melt <- DT_accuracy_byStim[,.(Subject,Stimulus,Deviation_L,Deviation_R)]
names(DT_accuracy_byStim_melt)[names(DT_accuracy_byStim_melt) == 'Deviation_L'] <- 'Left'
names(DT_accuracy_byStim_melt)[names(DT_accuracy_byStim_melt) == 'Deviation_R'] <- 'Right'
DT_accuracy_byStim_melt <- melt(DT_accuracy_byStim_melt, 
                                id.vars=c('Subject','Stimulus'),
                                variable.name='Eye',
                                value.name='Deviation')
```

```{r dev_fig2, echo = FALSE}

## plot parameters
figname_dev2 <- file.path(outpath,"Deviations_byStim.png")
plottitle <- "Deviation, by validation stimulus"
xlabel <- "Stimulus"
ylabel <- "Deviation [px]"
yaxis_min <- 0
yaxis_max <- max(DT_accuracy_byStim_melt$Deviation,na.rm=TRUE) + 10

## generate plot
g <- ggplot(DT_accuracy_byStim_melt, aes(x=Stimulus, y=Deviation, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(size=marker_size, stroke=marker_stroke) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) + 
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x = element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_dev2, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>


## Figure: Deviation values, by validation trial

This plot shows deviation values for each validation trial in the order in which they were presented. If validation stimuli are presented more than once (*e.g.* at beginning, middle, and end of experiment) this allows you to see at a glance if deviations are consistent or change (drift) over time. 

```{r dev_melt3, echo = FALSE}
## melt data in long format for plotting
DT_accuracy_byTrial_melt <- DT_accuracy_byStim[,.(Subject,Trial,Deviation_L,Deviation_R)]
names(DT_accuracy_byTrial_melt)[names(DT_accuracy_byTrial_melt) == 'Deviation_L'] <- 'Left'
names(DT_accuracy_byTrial_melt)[names(DT_accuracy_byTrial_melt) == 'Deviation_R'] <- 'Right'
DT_accuracy_byTrial_melt <- melt(DT_accuracy_byTrial_melt, 
                                id.vars=c('Subject','Trial'),
                                variable.name='Eye',
                                value.name='Deviation')
```

```{r dev_fig3, echo = FALSE}

## plot parameters
figname_dev3 <- file.path(outpath,"Deviations_byTrial.png")
plottitle <- "Deviation, by validation trial\n(in order presented)"
xlabel <- "Trial"
ylabel <- "Deviation [px]"
yaxis_min <- 0
yaxis_max <- max(DT_accuracy_byTrial_melt$Deviation,na.rm=TRUE) + 10

## generate plot
g <- ggplot(DT_accuracy_byTrial_melt, aes(x=Trial, y=Deviation, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(aes(stroke=marker_stroke)) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) + 
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x = element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_dev3, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>

***

# Distance from screen

Participants' average distance from the screen (using eye position Z value) is calculated for each eye during samples in which non-zero gaze data was collected (exluding non-experimental stimuli). This is probably not interesting/useful for deterimining which eye to use for analyses, but you might want to use the distance measure from the chosen eye when calculating a group average.  

```{r dist, echo = FALSE}
## get average distance from screen (when gaze was tracked)
DT_screenDistance_R <- DT_stimuli[, .(ScreenDistance_R = mean(REyePos_Z)),
                                by=.(Subject,TrackingR)]
DT_screenDistance_L <- DT_stimuli[, .(ScreenDistance_L = mean(LEyePos_Z)),
                                by=.(Subject,TrackingL)]
DT_screenDistance_R <- subset(DT_screenDistance_R, TrackingR==1)
DT_screenDistance_L <- subset(DT_screenDistance_L, TrackingL==1)
DT_screenDistance_R$TrackingR <- NULL
DT_screenDistance_L$TrackingL <- NULL
setkey(DT_screenDistance_R, Subject)
setkey(DT_screenDistance_L, Subject)
DT_screenDistance <- DT_screenDistance_R[DT_screenDistance_L]
```
<br>
<br> 

## Table: Distance from screen (during experimental trials)

*Distance is in mm*

```{r dist_table, echo = FALSE}
## display distance table
DT_screenDistance 
```
<br>
<br>

## Figure 3: Distance from screen

This plot shows each subject's average distance from the screen across all experimental trials.

```{r dist_melt1, echo = FALSE}
## melt data in long format for plotting
DT_screenDistance_melt <- DT_screenDistance[,.(Subject,ScreenDistance_L,ScreenDistance_R)]
names(DT_screenDistance_melt)[names(DT_screenDistance_melt) == 'ScreenDistance_L'] <- 'Left'
names(DT_screenDistance_melt)[names(DT_screenDistance_melt) == 'ScreenDistance_R'] <- 'Right'
DT_screenDistance_melt <- melt(DT_screenDistance_melt, 
                         id.vars=c('Subject'),
                         variable.name='Eye', 
                         value.name='ScreenDistance')
```

```{r dist_fig1, echo = FALSE}
## plot distance from screen by eye for each subject
figname_dist <- file.path(outpath,"DistanceFromScreen.png")
plottitle <- "Average distance from screen"
xlabel <- ""
ylabel <- "Distance [mm]"
yaxis_min = min(DT_screenDistance_melt$ScreenDistance,na.rm=TRUE) - 10
yaxis_max = max(DT_screenDistance_melt$ScreenDistance,na.rm=TRUE) + 10

## plot tracking ratio by eye for each subject
g <- ggplot(DT_screenDistance_melt, aes(x=1, y=ScreenDistance,
                                        ymin=yaxis_min, ymax=yaxis_max,
                                        color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(size=marker_size, stroke=marker_stroke) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + 
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_dist, width=4, height=4, units="in", dpi=300)
}
```

```{r summary_org, echo = FALSE}
## organize data for summary visualizations and data export

## set key variable and sort table by subject 
setkey(DT_tracking,Subject)
setkey(DT_accuracy,Subject)
setkey(DT_screenDistance,Subject)

## merge tracking and accuracy tables
DT_summary <- merge(DT_tracking,DT_accuracy, by="Subject", all=TRUE) # will keep all subjects even if no accuracy data
DT_summary <- merge(DT_summary,DT_screenDistance, by="Subject", all=TRUE) # will keep all subjects even if no distance data

## flag meaningful differences between eyes (thresholds set in parameters at beginning of script)
DT_summary$TrackingDiffAboveThresh[DT_summary$TrackingDiff <= Threshold_TrackingDiff] <- 0
DT_summary$TrackingDiffAboveThresh[DT_summary$TrackingDiff > Threshold_TrackingDiff] <- 1
DT_summary$AccuracyDiffAboveThresh[DT_summary$AccuracyDiff <= Threshold_AccuracyDiff] <- 0
DT_summary$AccuracyDiffAboveThresh[DT_summary$AccuracyDiff > Threshold_AccuracyDiff] <- 1

## if BetterTracking = NA, fill with Better Accuracy Eye
## if BetterAccuracy = NA, fill with "ALERT"
for(i in 1:nrow(DT_summary)) {
  if(is.na(DT_summary$BetterTracking[i])) {
    DT_summary$BetterTracking[i] <- DT_summary$BetterAccuracy[i]
  }
  if(is.na(DT_summary$BetterAccuracy[i])) {
    DT_summary$BetterAccuracy[i] <- "ALERT"
  }
}

## indicate if better tracking eye matches better accuracy eye or not
DT_summary$Match_TrackAccuracy[DT_summary$BetterTracking == DT_summary$BetterAccuracy] <- 1
DT_summary$Match_TrackAccuracy[DT_summary$BetterTracking != DT_summary$BetterAccuracy] <- 0

## reorder columns
setcolorder(DT_summary, c("Subject", "Match_TrackAccuracy", "BetterTracking", "TrackingDiffAboveThresh", "BetterAccuracy", "AccuracyDiffAboveThresh", setdiff(names(DT_summary), c("Subject", "Match_TrackAccuracy", "BetterTracking", "TrackingDiffAboveThresh", "BetterAccuracy", "AccuracyDiffAboveThresh"))))
```
<br>
<br>

***

# Eye recommendation by subject

The toolbox now uses the decision parameters outlined in the [Overview](#overview) section to recommend which eye provides 'better' data for each participant. The decision tree can be adjusted based on the priorities of the experiment (*e.g.*, if tracking accuracy is less important than data quantity).

A flag of **UNDETERMINED: missing data** indicates that there were no fixations within the specified AOIs for the stimuli listed in *ValidationStim*, so the toolbox cannot make a recommendation based on tracking accuracy information. A flag of **UNDETERMINED: conflict** indicates that one eye has a better tracking ratio and the other eye has better accuracy, so the user should examine the data and make a determination of which eye to use.

```{r rec, echo = FALSE}
## determine which eye should be used for analysis
for(i in 1:nrow(DT_summary)) {
  if(DT_summary$Match_TrackAccuracy[i] == 1) { 
    # if same eye is better for both tracking ratio and accuracy
    DT_summary$EyeRec[i] = DT_summary$BetterTracking[i] # use eye with better tracking ratio
  } else if(is.na(DT_summary$AccuracyDiffAboveThresh[i])) {
    # if no accuracy statistics (no looking to validation stimuli)
    DT_summary$EyeRec[i] = "UNDETERMINED: missing data" # flag for user to decide  
  } else if(DT_summary$TrackingDiffAboveThresh[i] == 1 & 
            DT_summary$AccuracyDiffAboveThresh[i] == 0) { 
    # if one eye has better tracking ratio and no difference between eyes for accuracy
    DT_summary$EyeRec[i] = DT_summary$BetterTracking[i] # use eye with better tracking ratio
  } else if(DT_summary$TrackingDiffAboveThresh[i] == 0 &
            DT_summary$AccuracyDiffAboveThresh[i] == 1) {
    # if one eye has better accuracy and no difference between eyes for tracking ratio
    DT_summary$EyeRec[i] = DT_summary$BetterAccuracy[i] # use eye with better accuracy
  } else if(DT_summary$TrackingDiffAboveThresh[i] == 0 &
            DT_summary$AccuracyDiffAboveThresh[i] == 0) {
    # if eyes are same for both tracking ratio and accuracy
    DT_summary$EyeRec[i] = DT_summary$BetterTracking[i] # use eye with better tracking ratio
  } else {
    # if one eye has better tracking ratio and OTHER eye has better accuracy
    DT_summary$EyeRec[i] = "UNDETERMINED: conflict" # flag for user to decide 
  }
}

DT_summary$EyeRec[DT_summary$EyeRec=="L"] <- "Left"
DT_summary$EyeRec[DT_summary$EyeRec=="R"] <- "Right"

## reorder columns
setcolorder(DT_summary, c("Subject", "EyeRec", setdiff(names(DT_summary), c("Subject", "EyeRec"))))
DT_summary$Subject <- as.character(DT_summary$Subject)
```

## Figure: Eye recommendations
```{r rec_fig1, echo = FALSE}

## plot eye recommendation for each subject
figname_rec <- file.path(outpath,"EyeRecommendations.png")
plottitle <- "Eye recommendation by subject"
xlabel <- "Eye recommendation"
ylabel <- "Subject"

## plot tracking ratio by eye for each subject
g <- ggplot(DT_summary, aes(x=EyeRec, y=Subject, 
                            color=EyeRec, shape=EyeRec, fill=EyeRec)) + 
  geom_point(size=marker_size+2, stroke=marker_stroke) + 
  scale_size(guide = 'none') +
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) + 
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 
g

## save figure to file
  ggsave(figname_rec, width=4, height=6, units="in", dpi=300)
```
<br>
<br>

## Table: Summary metrics/statistics table, with eye recommendations
This table is written to a .csv file and saved in the data directory.

**Variable definitions:**   

* *EyeRec:* This is the eye that has been determined to provide higher quality data and is recommended to be used for all subsequent analyses  
* *Match_TrackAccuracy:* This variable indicates if both tracking ratio and deviation metrics were better for the same eye (1) or if one eye had a better tracking ratio and the other eye had a lower validation deviation (0) 
* *BetterTracking:* Eye with higher tracking ratio
* *TrackingDiffAboveThresh:* Indicates if difference in tracking ratio between eyes exceeds threshold value  
* *BetterAccuracy:* Eye with lower deviation value   
* *AccuracyDiffAboveThresh:* Indicates if difference in deviation value between eyes exceeds threshold value  
* *TrackingDiff, TrackingRatio_L/R:* Tracking ratio values for each eye and difference between values  
* *TotalSamples:* Total number of eye tracking samples (experimental stimuli only) in data file (denominator for tracking ratio)  
* *NSamples_L/R:* Number of samples with non-zero gaze data (experimental stimuli only) for each eye (numerator for tracking ratio)  
* *AccuracyDiff, stdev_L/R, Duration_L/R, Deviation_L/R:* Difference between L/R deviation values, SD for deviation values (across stimuli), average duration of fixations used to calculate deviations 
* *ScreenDistance_L/R:* Average distance from screen [mm] for each eye (during experimental stimuli)   

```{r rec_table, echo = FALSE}
## write summary output to file
outputfile <- file.path(outpath,outputname)
write.csv(DT_summary, file = outputfile)

## display summary table
DT_summary 
```
<br>
<br>

***


# Appendix: Distributions of L/R differences relative to thresholds

This is meant to provide a visualization of the distribution of differences between eyes for quantity and accuracy metrics to help the user select threshold values for what constitutes a meaningful difference (and thus should be taken into account when choosing which eye's data to use for analyses).

<br>
<br>

## Histogram: Tracking ratio L/R difference 

Current threshold for a meaningful tracking ratio difference is `r Threshold_TrackingDiff`%. Currently, `r sum(DT_summary$TrackingDiffAboveThresh)` of `r nsubjects` participants have a tracking ratio difference above this threshold. 

```{r hist_tr, echo = FALSE}
ggplot(DT_summary, aes(x=TrackingDiff)) +
  geom_histogram(color=title_color, fill="white", size=1.5, binwidth=5) +
  geom_vline(xintercept=Threshold_TrackingDiff, color="red")
```
<br>
<br>

## Histogram: Deviation value (accuracy) L/R difference

Current threshold for a meaningful deviation value difference is `r Threshold_AccuracyDiff` pixels. Currently, `r sum(DT_summary$AccuracyDiffAboveThresh)` of `r nsubjects` participants have a deviation value difference above this threshold. 

```{r hist_dev, echo = FALSE}
ggplot(DT_summary, aes(x=AccuracyDiff)) +
  geom_histogram(color=title_color, fill="white", size=1.5, binwidth=5) +
  geom_vline(xintercept=Threshold_AccuracyDiff, color="red")
```
<br>
<br>

***

# Supplementary Feature: Precision

This metric was inspired by the toolbox created by Sam Wass and colleagues ([Wass et al., 2014)](https://onlinelibrary.wiley.com/doi/full/10.1111/infa.12055). 

***Currently, precision is included in the toolbox for visualization purposes only. This information is not integrated into the eye recommendation made above.***

**NOTE: The more data you have, the longer this chunk takes to run. To exclude this section, set *prec_on* parameter to FALSE** 

Precision is meant to be an indicator of how stable/jittery the estimated POR is over time. Perfectly precise tracking would be characterized by sustained periods of very small sample-to-sample changes in X/Y coordinates (fixations) separated by short periods of large changes (saccades) or missing data (blinks or looks away from the screen). Poor precision is charaterized by larger sample-to-samples changes in X/Y coordinates, even within fixations. In general, better precision is correlated with more accurate estimates of POR. The precision metric is an index of moment-to-moment stability in the location of the estimated POR ('jitter'), and does not take stability of the track itself ('flicker') or missing data into consideration.    

To calculate precision, looking data is broken into short time windows (window size defined in code, default is 100ms), calculates the median X/Y gaze coordinates within each window for each eye, and then computes a difference score for the X/Y coordinates at each time point relative to that window's median value. Windows with missing data for >= half are dropped from the analysis. Precision scores for each variable (RightX, RightY, LeftX, LeftY) are calculated by finding the median difference score for each coordinate across all experimental stimuli, and then overall precision scores are calculated for each eye by averaging X and Y precision scores. **Lower precision scores are better (*i.e.*, more stable gaze)**

\begin{aligned}
  MedianX_{window} &= median(PORX_{sample1},PORX_{sample2},...,PORX_{sampleN}) \\
  MedianY_{window} &= median(PORY_{sample1},PORY_{sample2},...,PORY_{sampleN}) \\  
  \\
  DifferenceX_{sample} &= \left\lvert PORX_{sample} - MedianX_{window} \right\rvert \\
  DifferenceY_{sample} &= \left\lvert PORY_{sample} - MedianY_{window} \right\rvert \\
  \\
  JitterX &= median(DifferenceX_{sample}) \\ 
  JitterY &= median(DifferenceY_{sample}) \\
  \\
  Precision &= median(\frac{JitterX + JitterY}{2})
\end{aligned}


```{r prec, echo = FALSE, include=FALSE}

if(prec_on == TRUE) {
  
## define window size (100ms)
WinSize=100

## break stimuli table into chunks of 1000 rows (otherwise loop takes forever)
nchunks = ceiling(nrow(DT_stimuli)/1000)

## initialize variables for window labeling
window = 1
cum_dur = 0 # cumulative duration for current window

## loop over chunks of data and label with window number
tic()
for(j in 1:nchunks) { # do one 'chunk' of data at a time
  DT_stimuli_temp <- DT_stimuli[((j*1000)-999):(j*1000),]
  DT_stimuli_temp <- na.omit(DT_stimuli_temp, cols="Time") # remove extra rows from last chunk if needed

  ## set values for first row of data
  DT_stimuli_temp$window[1] = window
  cum_dur = cum_dur + DT_stimuli_temp$Time_diff[1] # cumulative duration for current window

  ## loop over rows
  for(i in 2:nrow(DT_stimuli_temp)) {
    ## if same subject as previous row
    if(DT_stimuli_temp$Subject[i]==DT_stimuli_temp$Subject[i-1]) {
        ## increase current window cumulative duration
        cum_dur = cum_dur + DT_stimuli_temp$Time_diff[i]
        ## if window duration < set duration (plus 1/2 sample to account for rounding errors), within trial
        if(cum_dur < (WinSize+5) & (DT_stimuli_temp$Trial[i]==DT_stimuli_temp$Trial[i-1])) {
          DT_stimuli_temp$window[i] = window # keep current window value
        } else { # if cumulative duration is greater than window duration or it's a new trial
          window = window + 1 # increase window number
          DT_stimuli_temp$window[i] = window # label current row
          cum_dur = DT_stimuli_temp$Time_diff[1] # reset cumulative duration
        } # if(cum_dur < (WinSize+5) & ...)
    } else { # if subject is different from previous row
    window = 1 # restart window numbering
    DT_stimuli_temp$window[i] = window # label current row
    cum_dur = DT_stimuli_temp$Time_diff[i] # reset cumulative duration
    } # if(DT_stimuli$Subject[i]==
  } # for(i in 2:nrow(DT_stimuli_temp))

  if(j==1) { # first chunk
    DT_stimuli_windows <- DT_stimuli_temp
  } else { # bind chunks onto cumulative data table
    l = list(DT_stimuli_windows,DT_stimuli_temp)
    DT_stimuli_windows <- rbindlist(l)
  } # if(j==1)
} # for(i in 2:nrow(DT_stimuli))
toc() # this is here to display how long this loop takes to execute 

## replace 0 (missing) gaze coordinates with NA
DT_stimuli_windows$RPOR_X[DT_stimuli_windows$RPOR_X==0] <- NA
DT_stimuli_windows$RPOR_Y[DT_stimuli_windows$RPOR_Y==0] <- NA
DT_stimuli_windows$LPOR_X[DT_stimuli_windows$LPOR_X==0] <- NA
DT_stimuli_windows$LPOR_Y[DT_stimuli_windows$LPOR_Y==0] <- NA

## calculate median X/Y coordiantes within each window, by eye
DT_precision_R <- DT_stimuli_windows[,.(RPOR_X_median = median(RPOR_X,na.rm=TRUE),
                                        RPOR_Y_median = median(RPOR_Y,na.rm=TRUE),
                                        R_window_duration = sum(Time_diff)),
                                     by=.(Subject,window,TrackingR)]
DT_precision_L <- DT_stimuli_windows[,.(LPOR_X_median = median(LPOR_X,na.rm=TRUE),
                                        LPOR_Y_median = median(LPOR_Y,na.rm=TRUE),
                                        L_window_duration = sum(Time_diff,na.rm=TRUE)),
                                     by=.(Subject,window,TrackingL)]

## only keep valid windows with gaze for >=1/2 window duration (5ms buffer to account for rounding errors)
DT_precision_R <- subset(DT_precision_R, subset = TrackingR==1)
DT_precision_R$TrackingR <- NULL # no longer need this 
DT_precision_R <- subset(DT_precision_R, subset = R_window_duration > ((WinSize/2)-5))
DT_precision_L <- subset(DT_precision_L, subset = TrackingL==1)
DT_precision_L$TrackingL <- NULL # no longer need this 
DT_precision_L <- subset(DT_precision_L, subset = L_window_duration > ((WinSize/2)-5))

## merge window medians and durations with full dataset
DT_precision <- merge(DT_stimuli_windows,DT_precision_R,all=TRUE,
                      by=c('Subject','window'))
DT_precision <- merge(DT_precision,DT_precision_L,all=TRUE,
                       by=c('Subject','window'))

## calculate differences between POR and window median for each sample
DT_precision$RPOR_X_diff <- DT_precision[,.(abs(RPOR_X - RPOR_X_median))]
DT_precision$RPOR_Y_diff <- DT_precision[,.(abs(RPOR_Y - RPOR_Y_median))]
DT_precision$LPOR_X_diff <- DT_precision[,.(abs(LPOR_X - LPOR_X_median))]
DT_precision$LPOR_Y_diff <- DT_precision[,.(abs(LPOR_Y - LPOR_Y_median))]

## fill in missing sample numbers for each subject
DT_sampleInfo <- DT_precision[,.(firstSample = min(SampleNum),
                                 lastSample = max(SampleNum)),
                              by=.(Subject)]
for(i in 1:nrow(DT_sampleInfo)) {
  DT_temp <- data.table(Subject = DT_sampleInfo$Subject[i],
                        SampleNum = DT_sampleInfo$firstSample[i]:DT_sampleInfo$lastSample[i])
  DT_precision <- merge(DT_temp, DT_precision, by=c("Subject","SampleNum"), all=TRUE)
}

## average over X and Y differences to get average precision by eye (for plotting purposes only)
DT_precision$RPOR_avg_diff<- DT_precision[,.((RPOR_X_diff+RPOR_Y_diff)/2)]
DT_precision$LPOR_avg_diff<- DT_precision[,.((LPOR_X_diff+LPOR_Y_diff)/2)]

## calculate median difference values across all samples to get overall precision by variable
DT_precision_medians <- DT_precision[,.(RPORX_diff_median = median(RPOR_X_diff,na.rm=TRUE),
                                        RPORY_diff_median = median(RPOR_Y_diff,na.rm=TRUE),
                                        LPORX_diff_median = median(LPOR_X_diff,na.rm=TRUE),
                                        LPORY_diff_median = median(LPOR_Y_diff,na.rm=TRUE)),
                                     by=.(Subject)]

## average X/Y precision values to get overall precision score by eye
DT_precision_medians$RPOR_precision <- (DT_precision_medians$RPORX_diff_median + DT_precision_medians$RPORY_diff_median)/2
DT_precision_medians$LPOR_precision <- (DT_precision_medians$LPORX_diff_median + DT_precision_medians$LPORY_diff_median)/2

## determine which eye provided better precision (less jitter) for each subject
DT_precision_medians$BetterPrecision[DT_precision_medians$LPOR_precision > DT_precision_medians$RPOR_precision] <- "R"
DT_precision_medians$BetterPrecision[DT_precision_medians$LPOR_precision < DT_precision_medians$RPOR_precision] <- "L"
DT_precision_medians$PrecisionDiff <- abs(DT_precision_medians$LPOR_precision - DT_precision_medians$RPOR_precision)

setcolorder(DT_precision_medians, c("Subject", "BetterPrecision", "RPOR_precision", "LPOR_precision", setdiff(names(DT_precision_medians), c("Subject", "BetterPrecision", "RPOR_precision", "LPOR_precision"))))

} #end if prec_on=TRUE
```
<br>
<br>

## Table: Precision

* *BetterPrecision:* Which eye has better (lower) precision value across all stimuli
* *RPOR_precision:* Overall precision value for right eye (average of X and Y precision scores)
* *LPOR_precision:* Overall precision value for left eye (average of X and Y precision scores)  
* *RPORX_diff_median (etc.):* Precision score for right eye X-coordinates (median difference between RPOR_X and window median)
```{r prec_table, echo = FALSE}
if(prec_on == TRUE) {
  DT_precision_medians 
} #end if prec_on=TRUE
```
<br>
<br>

## Figure: Precision (example window)

Preciscion values for each eye at each time point are calculated by averaging X and Y difference values (differences between POR and smoothed gaze). Values close to zero indicate stable tracking (little to no difference between smoothed and unsmoothed values). Occasional spikes indicate large sample-to-sample changes (*e.g.*, saccades) and will not affect overall precion values (which are based on medians, not averages).

Because experiments often have thousands of samples, it is generally not useful to plot the entire experiment at once. By default, this figure plots a 500-sample window starting at the sample number defined by *xwindow_min*. To adjust the starting point of the plotted window, edit *xwindow_min* and to adjust the length of the plotted window, adjust *xwindow_max*. 

```{r prec_win, eval=TRUE, echo = FALSE, warning=FALSE, fig.width=5, fig.height=5}

if(prec_on == TRUE) {
  
## plot paramters
figname_precWin <- file.path(outpath,"Precision_window.png")
plottitle <- "Difference between raw POR and smoothed values (Precision)"
xlabel <- "Time (ET sample number)"
ylabel <- "Difference from window medians (averaged over X,Y) [px]"
xwindow_min <- 2000   # to set range of x values to be plotted (can change based on study parameters)
xwindow_max <- xwindow_min + 500

## generate plot
cols <- c("L Difference"=marker_colors[1],
          "R Difference"=marker_colors[2])
g <- ggplot(DT_precision, aes(x=SampleNum, y=LPOR_avg_diff)) +
  geom_line(aes(color="L Difference"), size=1) + 
  geom_line(aes(y=RPOR_avg_diff, color="R Difference"), alpha=.9) +
  xlim(xwindow_min, xwindow_max) + # comment this line out to plot entire experiment
  facet_wrap(~ Subject, ncol=1) + # to have yaxis scaled for each participant, add scales="free"
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(name="", guide='legend', values=cols) 

## save figure to file (if savefigstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_precWin, width=6, height=7, units="in", dpi=300)
}

} #end if prec_on=TRUE

if(prec_on == TRUE) {
  g
}
```
<br>
<br>

## Figure: Precision, overall medians

Plot of overall median precision values, by eye. Precision values close to zero indicate good overall precision, while higher values indicate less precision (more noise/jitter). Median precision values are derived from the difference between raw POR and smoothed window medians at each sample (see example window figure).

```{r prec_med, eval=prec_on, echo = FALSE}

if(prec_on == TRUE) {

## melt data in long format for plotting
DT_precision_melt <- DT_precision_medians[,.(Subject,RPOR_precision,LPOR_precision)]
names(DT_precision_melt)[names(DT_precision_melt) == 'LPOR_precision'] <- 'Left'
names(DT_precision_melt)[names(DT_precision_melt) == 'RPOR_precision'] <- 'Right'
DT_precision_melt <- melt(DT_precision_melt, 
                         id.vars=c('Subject'),
                         variable.name='Eye', 
                         value.name='Precision')
DT_precision_melt$Eye <- factor(DT_precision_melt$Eye, levels = c("Left", "Right"))
DT_precision_melt <- DT_precision_melt[order(Eye,Subject)] 

} #end if prec_on=TRUE
```

```{r prec_medFig, echo = FALSE, warning=FALSE}

if(prec_on == TRUE) {

## plot precision by eye for each subject
figname_precMed <- file.path(outpath,"Precision_median.png")
plottitle <- "Precision\n(median difference between smoothed and unsmoothed POR)"
xlabel <- " "
ylabel <- "Difference [px]"
yaxis_min <- 0

## plot tracking ratio by eye for each subject
g <- ggplot(DT_precision_melt, aes(x=1, y=Precision, 
                                  color=Eye, shape=Eye, fill=Eye,
                                  ymin=yaxis_min)) + 
  geom_point(size=marker_size, stroke=marker_stroke) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + 
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = yaxis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) +
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=legend_size,stroke=marker_stroke))) 

# save figure to file (if savefigstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_precMed, width=4, height=4, units="in", dpi=300)
}

} #end if prec_on=TRUE

if(prec_on == TRUE) {
  g
}
```
<br>
<br>



## Figure: Precision (Left eye)

This plot shows *LEFT EYE* raw gaze (POR) X and Y coordinates and smoothed window median coordinates for an example time window. Differences between POR and window medians are plotted near the x-axis. 

```{r precL, echo = FALSE, warning=FALSE, fig.width=8, fig.height=14}

if(prec_on == TRUE) {

## plot parameters
figname_precL <- file.path(outpath,"Precision_Left.png")
plottitle <- "LEFT EYE:\nSample raw and smoothed gaze, with difference values"
xlabel <- "Time (ET samples)"
ylabel <- "Coordinate [px]"

XPOR_color <- marker_colors[1]
XSmoothed_color <- marker_colors[1]
YPOR_color <- marker_colors[2]
YSmoothed_color <- marker_colors[2]

## generate plot
POR_shape <- 23
POR_alpha <- .5
Prec_shape <- 20
cols <- c("X POR"=marker_colors[1],"X Smoothed"=marker_colors[1],
          "Y POR"=marker_colors[2],"Y Smoothed"=marker_colors[2])
shapes <- c("X Difference"=Prec_shape, "Y Difference"=Prec_shape)
alphas <- c("X POR"=.5, "X Smoothed"=1, "Y POR"=.5, "Y Smoothed"=1)
g <- ggplot(DT_precision, aes(x=SampleNum, y=LPOR_X_diff)) +
  geom_point(aes(shape="X Difference"), color=marker_colors[1], alpha=.5) + 
  geom_point(aes(y=LPOR_Y_diff, shape="Y Difference"), color=marker_colors[2], alpha=.5) +
  geom_line(aes(y=LPOR_X_median, color="X Smoothed"), alpha=1, fill=NA) +
  geom_line(aes(y=LPOR_Y_median, color="Y Smoothed"), alpha=1) +
  geom_point(aes(y=LPOR_X, color="X POR"), shape=POR_shape, size=2, alpha=POR_alpha) +
  geom_point(aes(y=LPOR_Y, color="Y POR"), shape=POR_shape, size=2, alpha=POR_alpha) +
  xlim(xwindow_min, xwindow_max) +    # to set range of x values to be plotted (can change based on study parameters)
  facet_wrap(~ Subject, ncol=1, scales = "free") +
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=20, color=title_color, hjust = 0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = 16),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_colour_manual("", values = c(marker_colors[1], marker_colors[1],
                                     marker_colors[2], marker_colors[2]),
                      guide = guide_legend(override.aes = list(
                        linetype = c("blank", "solid", "blank", "solid"),
                         shape = c(POR_shape, NA, POR_shape, NA)))) +
  scale_shape_manual("", values = c(Prec_shape, Prec_shape), 
                     guide = guide_legend(override.aes = list(color=c(marker_colors[1], marker_colors[2]))))

# save figure to file (if savefigstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_precL, width=8, height=12, units="in", dpi=300)
}

} #end if prec_on=TRUE

if(prec_on == TRUE) {
  g
}
```


## Figure: Precision (Right eye)

This plot shows *RIGHT EYE* raw gaze (POR) X and Y coordinates and smoothed window median coordinates for an example time window. Differences between POR and window medians are plotted near the x-axis. 

```{r precR, echo = FALSE, warning=FALSE, fig.width=8, fig.height=14}

if(prec_on == TRUE) {

## plot parameters
figname_precR <- file.path(outpath,"Precision_Right.png")
plottitle <- "RIGHT EYE:\nSample raw and smoothed gaze, with difference values"
xlabel <- "Time (ET samples)"
ylabel <- "Coordinate [px]"

XPOR_color <- marker_colors[1]
XSmoothed_color <- marker_colors[1]
YPOR_color <- marker_colors[2]
YSmoothed_color <- marker_colors[2]

## generate plot
POR_shape <- 23
POR_alpha <- .5
Prec_shape <- 20
cols <- c("X POR"=marker_colors[1],"X Smoothed"=marker_colors[1],
          "Y POR"=marker_colors[2],"Y Smoothed"=marker_colors[2])
shapes <- c("X Difference"=Prec_shape, "Y Difference"=Prec_shape)
alphas <- c("X POR"=.5, "X Smoothed"=1, "Y POR"=.5, "Y Smoothed"=1)
g <- ggplot(DT_precision, aes(x=SampleNum, y=RPOR_X_diff)) +
  geom_point(aes(shape="X Difference"), color=marker_colors[1], alpha=.5) + 
  geom_point(aes(y=RPOR_Y_diff, shape="Y Difference"), color=marker_colors[2], alpha=.5) +
  geom_line(aes(y=RPOR_X_median, color="X Smoothed"), alpha=1, fill=NA) +
  geom_line(aes(y=RPOR_Y_median, color="Y Smoothed"), alpha=1) +
  geom_point(aes(y=RPOR_X, color="X POR"), shape=POR_shape, size=2, alpha=POR_alpha) +
  geom_point(aes(y=RPOR_Y, color="Y POR"), shape=POR_shape, size=2, alpha=POR_alpha) +
  xlim(xwindow_min, xwindow_max) +    # to set range of x values to be plotted (can change based on study parameters)
  facet_wrap(~ Subject, ncol=1, scales = "free") +
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=20, color=title_color, hjust = 0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = 16),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_colour_manual("", values = c(marker_colors[1], marker_colors[1],
                                     marker_colors[2], marker_colors[2]),
                      guide = guide_legend(override.aes = list(
                        linetype = c("blank", "solid", "blank", "solid"),
                         shape = c(POR_shape, NA, POR_shape, NA)))) +
  scale_shape_manual("", values = c(Prec_shape, Prec_shape), 
                     guide = guide_legend(override.aes = list(color=c(marker_colors[1], marker_colors[2]))))

# save figure to file (if savefigstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname_precR, width=8, height=12, units="in", dpi=300)
}

} #end if prec_on=TRUE

if(prec_on == TRUE) {
  g
}
```
<br>
<br>

***

# Contact 

Contact Heidi Baumgartner (heidibaum@gmail.com) with questions or with feature requests.

Special thanks to Kristen Tummeltshammer, Andrew Lynn, and other members of the DCN Lab at Brown University for help with testing and feature suggestions.

***

