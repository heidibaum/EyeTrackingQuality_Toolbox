---
title: "Eye Tracking Quality Toolbox"
author: "Heidi Baumgartner"
date: "5/2/2017"
output:
  html_document:
    toc: yes
    toc_depth: 2
    toc_float: yes
  word_document:
    toc: yes
    toc_depth: '2'
---

> written by Heidi Baumgartner and Rachel Martino at the [Developmental Cognitive Neuroscience Lab](http://research.clps.brown.edu/dcnl/) at Brown University, directed by Dr. Dima Amso  
![Caption](NotebookFigures/DCNL.png)  


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r include=FALSE}
## clear workspace to avoid interference from previous runs
rm(list=ls())

## load libraries (might have to install libraries if first time using)
library(ggplot2)
library(data.table)
library(rmarkdown)
```

# Overview

Some eye-tracking (ET) systems collect independent data streams from each eye (left and right), but analysis protocols often require the user to choose one eye or the other for analysis purposes. In optimal circumstances, it makes little difference which eye is used because these data streams are nearly identical. Sometimes, however, the data stream from one eye is significantly more stable or accurate than the stream from the other eye (*e.g.*, this situation occurs often when tracking very young participants with a between-eye distance that is at the lower limit of what the eye tracker can handle). 

This toolbox is designed to quantify the **TRACKING RATIO** (percent of ET samples with non-zero gaze coordinates) and calibration **ACCURACY** (deviation of estimated point-of-regard from defined coordinates) by eye (R/L) for eye tracking data and to **RECOMMEND** which eye to use for subsequent analyses based on these metrics. The toolbox is designed to work with data generated by BeGaze (SensoMotoric Instruments), but should work as long as the variables/format specified in [Using a non-SMI system](#using-a-non-smi-system) are present. 

*** 

# Instructions

Refer to the ET Quality Toolbox USER GUIDE for instructions on using the toolbox to generate quality metrics and eye recommendations.

***

# Set parameters

**These are the experiment-specific parameters that must be defined by the user.**  
*Once these parameters have been set, you should not have to edit code in other sections beyond tinkering with plot sizing.*

1. Update ***datadir*** to reflect correct path to data and ***outputname*** with desired name of summary output file  
    + **IMPORTANT:** Make sure that the *only* .txt file(s) in the directory specified by *datadir* is raw gaze data in the format specified above, because the toolbox will attempt to load/append all .txt files in *datadir*. Any files not in this format will cause the toolbox to break.
```{r echo=TRUE}
## path to data directory
datadir <- "/Users/heidibaumgartner/Documents/ETQuality_toolbox/ExampleData"

## file name for summary metrics
outputname <- "ETQuality_toolbox_output.csv"
```
<br>

2. **Set thresholds** for 'meaningful' differences (*i.e.*, discrepancies that are big enough to care about and  therefore should be used for eye choice determination) for the following metrics:
    + **Tracking ratio** (***Threshold_TrackingDiff***): default difference threshold is 5% (i.e., only use tracking ratio for eye choice recommendation if TR for one eye is >5% better than TR for other eye)
    + **Validation accuracy** (***Threshold_AccuracyDiff***): default difference threshold is 25 pixels (i.e., only use validation deviation values for eye choice recommendation if deviation values for one eye are >25 pixels closer to validation-stimulus center than deviation values for other eye)
```{r echo=TRUE}
## threshold for meaningful tracking ratio difference (%)
Threshold_TrackingDiff <- 5 # %

## threshold for meaningful deviation difference (pixels)
Threshold_AccuracyDiff <- 25  # pixels 
```
<br>

3. Define stimuli to be used for validation purposes (***ValidationStim***), AOIs (***ValidataionAOI***), and stimulus coordinates (***ValidationX/Y***)
    + Make sure that these four lists all have the same number of items 
    + If using the DCNL custom validation block, use default values  
```{r echo=TRUE}
## define names of stimuli used to measure validation accuracy
ValidationStim <- c('validation1.jpg',
                    'validation2.jpg',
                    'validation3.jpg',
                    'validation4.jpg')

## AOIs for corresponding items in 'ValidationStim'
ValidationAOI <- c('validation1',
                   'validation2',
                   'validation3',
                   'validation4')  

## X coordinates for center of corresponding items in 'ValidationStim'
ValidationX <- c(480, 
                 1440, 
                 480, 
                 1440) 

## Y coordinates for center of corresponding items in 'ValidationStim'
ValidationY <- c(270, 
                 270, 
                 810, 
                 810) 
```
<br>
    
4. Define experimental stimuli (***ExperimentalStim***) that you want to <U>INCLUDE</U> in tracking ratio and distance calculations 
    + To define non-experimental stimuli to <U>EXCLUDE</U> from these calculations instead, COMMENT OUT ***ExperimentalStim***  definition and use/edit ***FillerStim*** instead. 
    + If you want to <U>include all stimuli</U> in tracking ratio/distance calculations, comment out ***ExperimentalStim*** and use ***FillerStim <- c('nothing')***
```{r echo=TRUE}
## define stimulus names to be INCLUDED in tracking ratio/distance calculations 
ExperimentalStim <- c('Pic1.jpg', 'Pic2.jpg', 'Pic3.jpg', 'Movie1.avi', 'Movie2.avi')

## define filler stimulus names to be EXCLUDED from tracking ratio/distance calculations
# FillerStim <- c('Validation.jpg', 'validation1.jpg', 'validation2.jpg', 'validation3.jpg', 'validation4.jpg', 'Fixation.png')

## to include ALL stimuli in tracking ratio/distance calculations, use this instead
# FillerStim <- c('nothing')
```
<br>

5. Choose if you want to save plots to individual files (***saveplotstofile***) and edit plot aesthetics (e.g., color, marker shape) (optional)
```{r echo=TRUE}
## save plots as individual files?
saveplotstofile <- 1 # 0=no, 1=yes 

## Aesthetics for plots (can change as desired)
marker_colors <- c('#007c92', '#e98300', '#8c1515','#8c1515') 
marker_fills <- c('#007c92', NA, NA, NA) # NA for no fill
marker_shapes <- c(21,21,4,4) # 21=circle, 22=square, 23=diamond, 24=triangle, 25=invertedtriangle, 4=X
marker_size <- 2
marker_stroke <- 2
title_color <-  '#8c1515' 
title_size <- 16 # font size of plot titles
axis_size <- 12 # font size of axis titles

## grayscale color options
# marker_colors <- c('gray', 'black', 'black', 'black')
# marker_fills <- c('gray', NA, NA, NA)
# title_color <- 'black'
```
<br>
<br>

***

# Load and organize data

[You shouldn't need to change anything here unless you are using data generated outside of BeGaze and need to adjust for different variable names in data file(s).]

```{r warning=FALSE}
## This chunk loads data and organizes variable names

## create subdirectory in datadir to save plots
outpath <- file.path(datadir,"ETQtoolbox_output")
dir.create(outpath)
figpath <- paste(outpath,"/",sep="")

## identify all text files in data directory
setwd(datadir)
files = list.files(path=datadir, pattern="*.txt")

## load in data files and bind into single data table
DT_full = rbindlist(lapply(files, fread))

## rename variables as needed
names(DT_full)[names(DT_full) == 'Participant'] <- 'Subject'
names(DT_full)[names(DT_full) == 'RecordingTime [ms]'] <- 'Time'
names(DT_full)[names(DT_full) == 'Point of Regard Right X [px]'] <- 'RPOR_X'
names(DT_full)[names(DT_full) == 'Point of Regard Right Y [px]'] <- 'RPOR_Y'
names(DT_full)[names(DT_full) == 'Point of Regard Left X [px]'] <- 'LPOR_X'
names(DT_full)[names(DT_full) == 'Point of Regard Left Y [px]'] <- 'LPOR_Y'
names(DT_full)[names(DT_full) == 'AOI Name Right'] <- 'AOI_R'
names(DT_full)[names(DT_full) == 'AOI Name Left'] <- 'AOI_L'
names(DT_full)[names(DT_full) == 'Eye Position Right X [mm]'] <- 'REyePos_X'
names(DT_full)[names(DT_full) == 'Eye Position Right Y [mm]'] <- 'REyePos_Y'
names(DT_full)[names(DT_full) == 'Eye Position Right Z [mm]'] <- 'REyePos_Z'
names(DT_full)[names(DT_full) == 'Eye Position Left X [mm]'] <- 'LEyePos_X'
names(DT_full)[names(DT_full) == 'Eye Position Left Y [mm]'] <- 'LEyePos_Y'
names(DT_full)[names(DT_full) == 'Eye Position Left Z [mm]'] <- 'LEyePos_Z'
names(DT_full)[names(DT_full) == 'Index Right'] <- 'FixIndex_R'
names(DT_full)[names(DT_full) == 'Index Left'] <- 'FixIndex_L'

DT_full$Time_diff <- c(0, diff(DT_full$Time)) # calculate time difference between samples
nsubjects <- length(unique(DT_full$Subject)) # identify number of subjects

## replace extreme values with average time value (these happen mostly at subject boundaries but occasionally at other times as well)
DT_full$Time_diff[DT_full$Time_diff > 100] <- 16.7 
DT_full$Time_diff[DT_full$Time_diff <= 0] <- 16.7

## sort table by subject then time
DT_full <- DT_full[order(Subject,Time)]

```
<br>
<br>

***

# Tracking ratio 

Tracking Ratio is calculated by dividing the number of samples with non-0 gaze data (*TrackedSamples*) by total number of samples for the subset of stimuli defined above (either for stimuli defined in *ExperimentalStim* list or for all stimuli other than those defined in *FillerStim* list), then multiplied by 100 to convert to percentage.

\[
  TR = (\frac{TrackedSamples}{TotalSamples}) * 100
\]

```{r}
## create subset with only stimulus/stimuli you want to include in quantity/distance metrics (defined above) 
if(exists("ExperimentalStim")) { # if ExperimentalStim was defined
  DT_stimuli <- subset(DT_full, Stimulus %in% ExperimentalStim) 
} else { # if no ExperimentalStim definition, use FillerStim to exclude stimuli instead
  DT_stimuli <- subset(DT_full, !(Stimulus %in% FillerStim)) 
}

## determine number of unique experimental stimuli and max number of trials
nstim_exp <- length(unique(DT_stimuli$Stimulus))
ntrial_exp <- length(unique(DT_stimuli$Trial))

## initialize "Tracking" variables for each eye 
## (binary variable indicating if eye (L or R) provided non-zero gaze data on that sample)
DT_stimuli$TrackingR <- 0
DT_stimuli$TrackingL <- 0

## if X and Y coordinates are both not equal to 0, set tracking variable to 1
DT_stimuli$TrackingR[DT_stimuli$RPOR_X != 0 & DT_stimuli$RPOR_Y != 0] <- 1 
DT_stimuli$TrackingL[DT_stimuli$LPOR_X != 0 & DT_stimuli$LPOR_Y != 0] <- 1 

## get overall tracking ratios for each eye by subject
DT_tracking <- DT_stimuli[, .(TrackingRatio_R = round(mean(TrackingR)*100),
                              TrackingRatio_L = round(mean(TrackingL)*100),
                              NSamples_R = sum(TrackingR),
                              NSamples_L = sum(TrackingL),
                              TotalSamples = length(Time)),
                          by=.(Subject)]

## get tracking ratios for each stimulus by subject
DT_tracking_byStim <- DT_stimuli[, .(TrackingRatio_R = round(mean(TrackingR)*100),
                                     TrackingRatio_L = round(mean(TrackingL)*100),
                                     NSamples_R = sum(TrackingR),
                                     NSamples_L = sum(TrackingL),
                                     TotalSamples = length(Time)),
                                 by=.(Subject,Trial,Stimulus)]
```
<br>
<br>

## Table 1: Tracking ratio values and eye comparisons

* *BetterTracking:* Eye with better tracking ratio (difference between eyes not necessarily above threshold!)  
* *TrackingDiff:* Absolute difference of L and R tracking ratios

```{r}
## determine which eye provided more data for each subject
DT_tracking$BetterTracking[DT_tracking$TrackingRatio_L > DT_tracking$TrackingRatio_R] <- "L"
DT_tracking$BetterTracking[DT_tracking$TrackingRatio_L < DT_tracking$TrackingRatio_R] <- "R"
DT_tracking$TrackingDiff <- abs(DT_tracking$TrackingRatio_L - DT_tracking$TrackingRatio_R)

## reorder columns and display table with tracking ratios by subject
setcolorder(DT_tracking, c("Subject", "BetterTracking", "TrackingDiff", "TrackingRatio_L", "TrackingRatio_R", "TotalSamples", "NSamples_L","NSamples_R"))

## display tracking ratio table
DT_tracking 
```
<br>
<br>

## Figure 1a: Tracking ratio

This plot provides a quick visualization of tracking ratio by eye for each subject. 

```{r}
## melt data in long format for plotting
DT_tracking_melt <- DT_tracking[,.(Subject,TrackingRatio_L,TrackingRatio_R)]
names(DT_tracking_melt)[names(DT_tracking_melt) == 'TrackingRatio_L'] <- 'Left'
names(DT_tracking_melt)[names(DT_tracking_melt) == 'TrackingRatio_R'] <- 'Right'
DT_tracking_melt <- melt(DT_tracking_melt, 
                         id.vars=c('Subject'),
                         variable.name='Eye', 
                         value.name='TrackingRatio')
```

```{r}
## to control display size of plot, add these parameters to {r} and adjust values.
## fig.width=8, fig.height=8

## plot parameters
figname1a <- file.path(outpath,"1a_TrackingRatio_overall.png")
plottitle <- "Tracking ratio"
xlabel <- " "
ylabel <- "Tracking ratio [%]"
yaxis_min <- 0
yaxis_max <- 100

## generate plot
g <- ggplot(DT_tracking_melt, aes(x=1, y=TrackingRatio, 
                                  ymin=yaxis_min, ymax=yaxis_max,
                                  color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(aes(size=marker_size, stroke=marker_stroke)) + #
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = axis_size),
        legend.position = "top", 
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=4,stroke=2))) 
g 

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname1a, width=4, height=4, units="in", dpi=300)
}
```
<br>
<br>

## Figure 1b: Tracking ratio, by stimulus (all trials)

This plot provides a visualization of tracking ratio by stimulus. This allows you to quickly see if tracking ratio differs or is consistent across stimuli. Each circle represents a single presentation of the stimulus. Data points are jittered so that if stimuli are presented more than once, you will be able to see the tracking ratio during each presentation. 

*NOTE: If stimuli do not repeat (1 trial per stimulus), this figure will be redundant with Figure 1c.*

```{r}
## melt data in long format for plotting
DT_tracking_byStim_melt <- DT_tracking_byStim[,.(Subject,Stimulus,TrackingRatio_L,TrackingRatio_R)]
names(DT_tracking_byStim_melt)[names(DT_tracking_byStim_melt) == 'TrackingRatio_L'] <- 'Left'
names(DT_tracking_byStim_melt)[names(DT_tracking_byStim_melt) == 'TrackingRatio_R'] <- 'Right'
DT_tracking_byStim_melt <- melt(DT_tracking_byStim_melt, 
                                id.vars=c('Subject','Stimulus'),
                                variable.name='Eye',
                                value.name='TrackingRatio')
```

```{r}

## plot parameters
figname1b <- file.path(outpath,"1b_TrackingRatio_byStimulus.png")
plottitle <- "Tracking ratio, by stimulus\n(all presentations)"
xlabel <- "Stimulus"
ylabel <- "Tracking Ratio [%]"
yaxis_min <- 0
yaxis_max <- 100

## generate plot 
g <- ggplot(DT_tracking_byStim_melt, aes(x=Stimulus, y=TrackingRatio, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_jitter(size=marker_size,stroke=marker_stroke, alpha=1, width=.1) + # jitters points to make multiple trials visible
  scale_size(guide='none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size=axis_size),
        legend.position="top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour=guide_legend(override.aes=list(size=4,stroke=2)))
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname1b, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>


## Figure 1c: Tracking ratio, by stimulus (stimulus averages)

This plot provides a visualization of tracking ratio by stimulus. If stimuli are presented more than once, the data point represents the tracking ratio (by eye) averaged across all presentations of that stimulus.

*NOTE: If stimuli do not repeat (1 trial per stimulus), this figure will be redundant with Figure 1b.*

```{r}
## melt data in long format for plotting
DT_tracking_byStim_means <- DT_tracking_byStim_melt[,.(TrackingRatio = mean(TrackingRatio)),
                                                    by=.(Subject,Stimulus,Eye)]
```

```{r}

## plot parameters
figname1c <- file.path(outpath,"1c_TrackingRatio_byStimulus_mean.png")
plottitle <- "Tracking ratio, by stimulus\n(averaged over repeat presentations)"
xlabel <- "Stimulus"
ylabel <- "Tracking Ratio [%]"
yaxis_min <- 0
yaxis_max <- 100

## generate plot
g <- ggplot(DT_tracking_byStim_means, aes(x=Stimulus, y=TrackingRatio, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(aes(size=marker_size,stroke=marker_stroke)) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) + 
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x = element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = axis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=4,stroke=2))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname1c, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>


## Figure 1d: Tracking ratio, by trial

This plot provides a visualization of tracking ratio by trial. This allows you to quickly see if a subject's tracking ratio is consistent or changes over time. 

```{r}
## melt data in long format for plotting
DT_tracking_byTrial_melt <- DT_tracking_byStim[,.(Subject,Trial,TrackingRatio_L,TrackingRatio_R)]
names(DT_tracking_byTrial_melt)[names(DT_tracking_byTrial_melt) == 'TrackingRatio_L'] <- 'Left'
names(DT_tracking_byTrial_melt)[names(DT_tracking_byTrial_melt) == 'TrackingRatio_R'] <- 'Right'
DT_tracking_byTrial_melt <- melt(DT_tracking_byTrial_melt, 
                                id.vars=c('Subject','Trial'),
                                variable.name='Eye',
                                value.name='TrackingRatio')
```

```{r}

## plot parameters
figname1d <- file.path(outpath,"1d_TrackingRatio_byTrial.png")
plottitle <- "Tracking ratio, by trial"
xlabel <- "Trial"
ylabel <- "Tracking Ratio [%]"
yaxis_min <- 0
yaxis_max <- 100

## generate plot
g <- ggplot(DT_tracking_byTrial_melt, aes(x=Trial, y=TrackingRatio, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(aes(size=marker_size,stroke=marker_stroke)) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) + 
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x = element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = axis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=4,stroke=2))) 
g

# save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname1d, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>


***

# Calibration accuracy

Deviation statistics are calculated using the longest fixation to the validation stimulus on each validation trial (based on the assumption that the longest fixation that falls within the validation AOI on each trial most likely reflects looking to the validation stimulus). The average euclidean distance (deviation) from each point-of-regard (POR) within the longest fixation to the validation stimulus is calculated for each trial. Deviation values are then averaged over all validation trials to generate an average deviation value. 

\begin{aligned}
  Deviation_{sample} &= \sqrt{(STIM_{x}-POR_{x})^2+(STIM_{y}-POR_{y})^2} \\
  Deviation_{fixation} &= mean(Deviation_{samples}) \\
  Deviation_{average} &= mean(Deviation_{LongestFixations})
\end{aligned}

```{r}
## create subset with validation stimuli
DT_validation <- subset(DT_full, Stimulus %in% ValidationStim) # name of validation stimulus

## determine number of unique validation stimuli and max number of validation trials
nstim_val <- length(unique(DT_validation$Stimulus))
ntrial_val <- length(unique(DT_validation$Trial))

## match validation stimulus coordinates with corresponding stimuli
for(i in 1:length(ValidationStim)) {
  DT_validation$StimulusX[DT_validation$Stimulus == ValidationStim[i]] <- ValidationX[i]
  DT_validation$StimulusY[DT_validation$Stimulus == ValidationStim[i]] <- ValidationY[i]
}

## calculate POR deviation from validation stimulus for each eye
DT_validation$Deviation_L <- DT_validation[,.(sqrt((StimulusX-LPOR_X)^2 +
                                                    (StimulusY-LPOR_Y)^2))]
DT_validation$Deviation_R <- DT_validation[,.(sqrt((StimulusX-RPOR_X)^2 +
                                                    (StimulusY-RPOR_Y)^2))]
## only keep distance values for fixations within appropriate AOIs
for(i in 1:length(ValidationStim)) {
  DT_validation$Deviation_L[DT_validation$Stimulus == ValidationStim[i] & DT_validation$AOI_L != ValidationAOI[i]] <- NA
  DT_validation$Deviation_R[DT_validation$Stimulus == ValidationStim[i] & DT_validation$AOI_R != ValidationAOI[i]] <- NA
}

## calculate deviation from center, stdev of deviation, and duration of each fixation by eye
DT_accuracy_L <- DT_validation[,.(Deviation_L = mean(Deviation_L, na.rm=TRUE),
                                  stdev_L = sd(Deviation_L, na.rm=TRUE),
                                  Duration_L = sum(Time_diff)),
                             by = .(Subject,Trial,`Category Left`,FixIndex_L, Stimulus)]
DT_accuracy_R <- DT_validation[,.(Deviation_R = mean(Deviation_R, na.rm=TRUE),
                                  stdev_R = sd(Deviation_R, na.rm=TRUE),
                                  Duration_R = sum(Time_diff)),
                             by = .(Subject,Trial,`Category Right`,FixIndex_R, Stimulus)]

## keep only fixation data (get rid of blinks and saccades)
DT_accuracy_L <- subset(DT_accuracy_L, `Category Left` == "Fixation")
DT_accuracy_R <- subset(DT_accuracy_R, `Category Right` == "Fixation")
## keep only fixations within validation AOI (ie, have a deviation value)
DT_accuracy_L <- subset(DT_accuracy_L, Deviation_L > 0)
DT_accuracy_R <- subset(DT_accuracy_R, Deviation_R > 0)
DT_accuracy_L <- subset(DT_accuracy_L, stdev_L > 0)
DT_accuracy_R <- subset(DT_accuracy_R, stdev_R > 0)

## identify longest fixation to validation AOI on each trial
DT_accuracy_L <- DT_accuracy_L[DT_accuracy_L[, .I[Duration_L == max(Duration_L)],
                                             by=.(Subject,Trial)]$V1]
DT_accuracy_R <- DT_accuracy_R[DT_accuracy_R[, .I[Duration_R == max(Duration_R)],
                                             by=.(Subject,Trial)]$V1]

## average across trials
DT_accuracy_L_means <- DT_accuracy_L[,.(Deviation_L = mean(Deviation_L),
                                        stdev_L = mean(stdev_L),
                                        Duration_L = mean(Duration_L)),
                                     by = Subject]
DT_accuracy_R_means <- DT_accuracy_R[,.(Deviation_R = mean(Deviation_R),
                                        stdev_R = mean(stdev_R),
                                        Duration_R = mean(Duration_R)),
                                     by = Subject]
## merge tables by subject
DT_accuracy_byStim <- merge(DT_accuracy_L,DT_accuracy_R, by=c("Subject","Trial","Stimulus"), all=TRUE)
DT_accuracy <- merge(DT_accuracy_L_means,DT_accuracy_R_means, by="Subject", all=TRUE)

## determine which eye provided more accurate data for each subject
DT_accuracy$BetterAccuracy[DT_accuracy$Deviation_L > DT_accuracy$Deviation_R] <- "R"
DT_accuracy$BetterAccuracy[DT_accuracy$Deviation_L < DT_accuracy$Deviation_R] <- "L"
DT_accuracy$AccuracyDiff <- abs(DT_accuracy$Deviation_L - DT_accuracy$Deviation_R)
```
<br>

## Table 2: Deviation values

* *BetterAccuracy:* Eye with better (*i.e.*, smaller) deviation value (not necessarily above threshold!)  
* *AccuracyDiff:* Absolute difference of L and R deviation values  
* *stdev_L/R:* Average standard deviation of deviation values within each fixation (higher values indicate less stable fixations)
* *Duration_L/R:* Average fixation duration of fixations used to calculate deviations

```{r}
## reorder columns and display accuracy table
setcolorder(DT_accuracy, c("Subject", "BetterAccuracy", "AccuracyDiff", 
                           setdiff(names(DT_accuracy), c("Subject", "BetterAccuracy","AccuracyDiff"))))

## display table with deviation values
DT_accuracy # display accuracy table
```
<br>
<br>


## Figure 2a: Deviation values

This plot shows average deviation values (i.e., average distance of estimated POR from center of validation stimulus) by eye for each subject. Smaller deviation values indicate a better calibration/more accurate tracking. 

```{r}
## melt data in long format for plotting
DT_accuracy_melt <- DT_accuracy[,.(Subject,Deviation_L,Deviation_R)]
names(DT_accuracy_melt)[names(DT_accuracy_melt) == 'Deviation_L'] <- 'Left'
names(DT_accuracy_melt)[names(DT_accuracy_melt) == 'Deviation_R'] <- 'Right'
DT_accuracy_melt <- melt(DT_accuracy_melt, 
                         id.vars=c('Subject'),
                         variable.name='Eye', 
                         value.name='Deviation')
```

```{r}

## plot parameters
figname2a <- file.path(outpath,"2a_Deviations_overall.png")
plottitle <- "Average deviation\n(smaller is better!)"
xlabel <- " "
ylabel <- "Deviation [px]"
yaxis_min <- 0
yaxis_max <- max(DT_accuracy_melt$Deviation,na.rm=TRUE) + 10

## generate plot
g <- ggplot(DT_accuracy_melt, aes(x=1, y=Deviation, 
                                  ymin=yaxis_min, ymax=yaxis_max,
                                  color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(aes(size=marker_size, stroke=marker_stroke)) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = axis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=4,stroke=2))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname2a, width=4, height=4, units="in", dpi=300)
}
```
<br>
<br>


## Figure 2b: Deviation values, by validation stimulus

This plot shows deviation values for each validation stimulus. This allows you to see at a glance if high deviations are due to a generally poor calibration (consistently high values across stimuli) or outlier value(s). It also allows you to see if any participants are missing data for one or more validation stimuli (missing data will result in a displayed warning before the plot).

```{r}
## melt data in long format for plotting
DT_accuracy_byStim_melt <- DT_accuracy_byStim[,.(Subject,Stimulus,Deviation_L,Deviation_R)]
names(DT_accuracy_byStim_melt)[names(DT_accuracy_byStim_melt) == 'Deviation_L'] <- 'Left'
names(DT_accuracy_byStim_melt)[names(DT_accuracy_byStim_melt) == 'Deviation_R'] <- 'Right'
DT_accuracy_byStim_melt <- melt(DT_accuracy_byStim_melt, 
                                id.vars=c('Subject','Stimulus'),
                                variable.name='Eye',
                                value.name='Deviation')
```

```{r}

## plot parameters
figname2b <- file.path(outpath,"2b_Deviations_byStimulus.png")
plottitle <- "Deviation, by validation stimulus"
xlabel <- "Stimulus"
ylabel <- "Deviation [px]"
yaxis_min <- 0
yaxis_max <- max(DT_accuracy_byStim_melt$Deviation,na.rm=TRUE) + 10

## generate plot
g <- ggplot(DT_accuracy_byStim_melt, aes(x=Stimulus, y=Deviation, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(aes(size=marker_size, stroke=marker_stroke)) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) + 
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x = element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = axis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=4,stroke=2))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname2b, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>


## Figure 2c: Deviation values, validation trial

This plot shows deviation values for each validation trial in the order in which they were presented. This allows you to see at a glance if deviations are consistent or change (drift) over time. 

```{r}
## melt data in long format for plotting
DT_accuracy_byTrial_melt <- DT_accuracy_byStim[,.(Subject,Trial,Deviation_L,Deviation_R)]
names(DT_accuracy_byTrial_melt)[names(DT_accuracy_byTrial_melt) == 'Deviation_L'] <- 'Left'
names(DT_accuracy_byTrial_melt)[names(DT_accuracy_byTrial_melt) == 'Deviation_R'] <- 'Right'
DT_accuracy_byTrial_melt <- melt(DT_accuracy_byTrial_melt, 
                                id.vars=c('Subject','Trial'),
                                variable.name='Eye',
                                value.name='Deviation')
```

```{r}

## plot parameters
figname2c <- file.path(outpath,"2c_Deviations_byTrial.png")
plottitle <- "Deviation, by validation trial\n(in order presented)"
xlabel <- "Trial"
ylabel <- "Deviation [px]"
yaxis_min <- 0
yaxis_max <- max(DT_accuracy_byTrial_melt$Deviation,na.rm=TRUE) + 10

## generate plot
g <- ggplot(DT_accuracy_byTrial_melt, aes(x=Trial, y=Deviation, 
                                         ymin=yaxis_min, ymax=yaxis_max,
                                         color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(aes(size=marker_size, stroke=marker_stroke)) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + # to control number of columns, add ncol= parameter
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) + 
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x = element_text(angle=60, vjust=0.5),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = axis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=4,stroke=2))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname2c, width=5, height=4, units="in", dpi=300)
}
```
<br>
<br>


***

# Distance from screen

Participants' average distance from the screen (using eye position Z value) is calculated for each eye during samples in which non-zero gaze data was collected (exluding non-experimental stimuli). This is probably not interesting/useful for deterimining which eye to use for analyses, but you might want to use the distance measure from the chosen eye when calculating a group average.  

```{r}
## get average distance from screen (when gaze was tracked)
DT_screenDistance_R <- DT_stimuli[, .(ScreenDistance_R = mean(REyePos_Z)),
                                by=.(Subject,TrackingR)]
DT_screenDistance_L <- DT_stimuli[, .(ScreenDistance_L = mean(LEyePos_Z)),
                                by=.(Subject,TrackingL)]
DT_screenDistance_R <- subset(DT_screenDistance_R, TrackingR==1)
DT_screenDistance_L <- subset(DT_screenDistance_L, TrackingL==1)
DT_screenDistance_R$TrackingR <- NULL
DT_screenDistance_L$TrackingL <- NULL
setkey(DT_screenDistance_R, Subject)
setkey(DT_screenDistance_L, Subject)
DT_screenDistance <- DT_screenDistance_R[DT_screenDistance_L]
```
<br>
<br> 

## Table 3: Distance from screen (during experimental trials)

*Distance is in mm*

```{r}
## display distance table
DT_screenDistance 
```
<br>
<br>

## Figure 3: Distance from screen

This plot shows each subject's average distance from the screen across all experimental trials.

```{r}
## melt data in long format for plotting
DT_screenDistance_melt <- DT_screenDistance[,.(Subject,ScreenDistance_L,ScreenDistance_R)]
names(DT_screenDistance_melt)[names(DT_screenDistance_melt) == 'ScreenDistance_L'] <- 'Left'
names(DT_screenDistance_melt)[names(DT_screenDistance_melt) == 'ScreenDistance_R'] <- 'Right'
DT_screenDistance_melt <- melt(DT_screenDistance_melt, 
                         id.vars=c('Subject'),
                         variable.name='Eye', 
                         value.name='ScreenDistance')
```

```{r}
## plot distance from screen by eye for each subject
figname3 <- file.path(outpath,"3_DistanceFromScreen.png")
plottitle <- "Average distance from screen"
xlabel <- ""
ylabel <- "Distance [mm]"
yaxis_min = min(DT_screenDistance_melt$ScreenDistance,na.rm=TRUE) - 10
yaxis_max = max(DT_screenDistance_melt$ScreenDistance,na.rm=TRUE) + 10

## plot tracking ratio by eye for each subject
g <- ggplot(DT_screenDistance_melt, aes(x=1, y=ScreenDistance,
                                        ymin=yaxis_min, ymax=yaxis_max,
                                        color=Eye, shape=Eye, fill=Eye)) + 
  geom_point(aes(size=marker_size,stroke=marker_stroke)) + 
  scale_size(guide = 'none') +
  facet_wrap(~ Subject) + 
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.text.x=element_blank(),
        axis.ticks=element_blank(),
        axis.title.y=element_text(size = axis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=4,stroke=2))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname3, width=4, height=4, units="in", dpi=300)
}
```

```{r}
## organize data for summary visualizations and data export

## set key variable and sort table by subject 
setkey(DT_tracking,Subject)
setkey(DT_accuracy,Subject)
setkey(DT_screenDistance,Subject)

## merge tracking and accuracy tables
DT_summary <- merge(DT_tracking,DT_accuracy, by="Subject", all=TRUE) # will keep all subjects even if no accuracy data
DT_summary <- merge(DT_summary,DT_screenDistance, by="Subject", all=TRUE) # will keep all subjects even if no distance data

## flag meaningful differences between eyes (thresholds set in parameters at beginning of script)
DT_summary$TrackingDiffAboveThresh[DT_summary$TrackingDiff <= Threshold_TrackingDiff] <- 0
DT_summary$TrackingDiffAboveThresh[DT_summary$TrackingDiff > Threshold_TrackingDiff] <- 1
DT_summary$AccuracyDiffAboveThresh[DT_summary$AccuracyDiff <= Threshold_AccuracyDiff] <- 0
DT_summary$AccuracyDiffAboveThresh[DT_summary$AccuracyDiff > Threshold_AccuracyDiff] <- 1

## if BetterTracking = NA, fill with Better Accuracy Eye
## if BetterAccuracy = NA, fill with "ALERT"
for(i in 1:nrow(DT_summary)) {
  if(is.na(DT_summary$BetterTracking[i])) {
    DT_summary$BetterTracking[i] <- DT_summary$BetterAccuracy[i]
  }
  if(is.na(DT_summary$BetterAccuracy[i])) {
    DT_summary$BetterAccuracy[i] <- "ALERT"
  }
}

## indicate if better tracking eye matches better accuracy eye or not
DT_summary$Match_TrackAccuracy[DT_summary$BetterTracking == DT_summary$BetterAccuracy] <- 1
DT_summary$Match_TrackAccuracy[DT_summary$BetterTracking != DT_summary$BetterAccuracy] <- 0

## reorder columns
setcolorder(DT_summary, c("Subject", "Match_TrackAccuracy", "BetterTracking", "TrackingDiffAboveThresh", "BetterAccuracy", "AccuracyDiffAboveThresh", setdiff(names(DT_summary), c("Subject", "Match_TrackAccuracy", "BetterTracking", "TrackingDiffAboveThresh", "BetterAccuracy", "AccuracyDiffAboveThresh"))))
```
<br>
<br>

***

# Eye recommendation by subject

The toolbox now uses the decision parameters outlined in the [Overview](#overview) section to recommend which eye provides 'better' data for each participant. The decision tree can be adjusted based on the priorities of the experiment (*e.g.*, if tracking accuracy is less important than data quantity).

A flag of **UNDETERMINED: missing data** indicates that there were no fixations within the specified AOIs for the stimuli listed in *ValidationStim*, so the toolbox cannot make a recommendation based on tracking accuracy information. A flag of **UNDETERMINED: conflict** indicates that one eye has a better tracking ratio and the other eye has better accuracy, so the user should examine the data and make a determination of which eye to use.

```{r}
## determine which eye should be used for analysis
for(i in 1:nrow(DT_summary)) {
  if(DT_summary$Match_TrackAccuracy[i] == 1) { 
    # if same eye is better for both tracking ratio and accuracy
    DT_summary$EyeChoice[i] = DT_summary$BetterTracking[i] # use eye with better tracking ratio
  } else if(is.na(DT_summary$AccuracyDiffAboveThresh[i])) {
    # if no accuracy statistics (no looking to validation stimuli)
    DT_summary$EyeChoice[i] = "UNDETERMINED: missing data" # flag for user to decide  
  } else if(DT_summary$TrackingDiffAboveThresh[i] == 1 & 
            DT_summary$AccuracyDiffAboveThresh[i] == 0) { 
    # if one eye has better tracking ratio and no difference between eyes for accuracy
    DT_summary$EyeChoice[i] = DT_summary$BetterTracking[i] # use eye with better tracking ratio
  } else if(DT_summary$TrackingDiffAboveThresh[i] == 0 &
            DT_summary$AccuracyDiffAboveThresh[i] == 1) {
    # if one eye has better accuracy and no difference between eyes for tracking ratio
    DT_summary$EyeChoice[i] = DT_summary$BetterAccuracy[i] # use eye with better accuracy
  } else if(DT_summary$TrackingDiffAboveThresh[i] == 0 &
            DT_summary$AccuracyDiffAboveThresh[i] == 0) {
    # if eyes are same for both tracking ratio and accuracy
    DT_summary$EyeChoice[i] = DT_summary$BetterTracking[i] # use eye with better tracking ratio
  } else {
    # if one eye has better tracking ratio and OTHER eye has better accuracy
    DT_summary$EyeChoice[i] = "UNDETERMINED: conflict" # flag for user to decide 
  }
}

DT_summary$EyeChoice[DT_summary$EyeChoice=="L"] <- "Left"
DT_summary$EyeChoice[DT_summary$EyeChoice=="R"] <- "Right"

## reorder columns
setcolorder(DT_summary, c("Subject", "EyeChoice", setdiff(names(DT_summary), c("Subject", "EyeChoice"))))
DT_summary$Subject <- as.character(DT_summary$Subject)
```

## Figure 4: Eye recommendations
```{r}

## plot eye choice for each subject
figname4 <- file.path(outpath,"4_EyeChoices.png")
plottitle <- "Eye recommendation by subject"
xlabel <- "Subject"
ylabel <- "Eye recommendation"

## plot tracking ratio by eye for each subject
g <- ggplot(DT_summary, aes(x=Subject, y=EyeChoice, 
                            color=EyeChoice, shape=EyeChoice, fill=EyeChoice)) + 
  geom_point(aes(size=marker_size, stroke=marker_stroke)) + 
  scale_size(guide = 'none') +
  labs(x=xlabel,
       y=ylabel,
       title=plottitle) +
  theme(plot.title=element_text(size=title_size, color=title_color, hjust = 0.5),
        axis.title.y=element_text(size = axis_size),
        legend.position = "top",
        legend.box.background = element_rect()) +
  scale_color_manual(values = marker_colors) +
  scale_fill_manual(values = marker_fills) + 
  scale_shape_manual(values = marker_shapes) +
  guides(colour = guide_legend(override.aes = list(size=4,stroke=2))) 
g

## save figure to file (if saveplotstofile==1 in Parameters)
if(saveplotstofile==1){
  ggsave(figname4, width=6, height=4, units="in", dpi=300)
}
```
<br>
<br>

## Table 4: Summary metrics/statistics table, with eye recommendations
This table is written to a .csv file and saved in the data directory.

**Variable definitions:**   

* *EyeChoice:* This is the eye that has been determined to provide higher quality data and should thus be used for all subsequent analyses  
* *Match_TrackAccuracy:* This variable indicates if both tracking ratio and deviation metrics were better for the same eye (1) or if one eye had a better tracking ratio and the other eye had a lower validation deviation (0) 
* *BetterTracking:* Eye with higher tracking ratio
* *TrackingDiffAboveThresh:* Indicates if difference in tracking ratio between eyes exceeds threshold value  
* *BetterAccuracy:* Eye with lower deviation value   
* *AccuracyDiffAboveThresh:* Indicates if difference in deviation value between eyes exceeds threshold value  
* *TrackingDiff, TrackingRatio_L/R:* Tracking ratio values for each eye and difference between values  
* *TotalSamples:* Total number of eye tracking samples (experimental stimuli only) in data file (denominator for tracking ratio)  
* *NSamples_L/R:* Number of samples with non-zero gaze data (experimental stimuli only) for each eye (numerator for tracking ratio)  
* *AccuracyDiff, stdev_L/R, Duration_L/R, Deviation_L/R:* Difference between L/R deviation values, SD for deviation values (across stimuli), average duration of fixations used to calculate deviations 
* *ScreenDistance_L/R:* Average distance from screen [mm] for each eye (during experimental stimuli)   

```{r}
## write summary output to file
outputfile <- file.path(outpath,outputname)
write.csv(DT_summary, file = outputfile)

## display summary table
DT_summary 
```
<br>
<br>

***


# Appendix: Distributions of L/R differences relative to thresholds

This is meant to provide a visualization of the distribution of differences between eyes for quantity and accuracy metrics to help the user select threshold values for what constitutes a meaningful difference (and thus should be taken into account when choosing which eye's data to use for analyses).

<br>
<br>

## Histogram: Tracking ratio L/R difference 

Current threshold for a meaningful tracking ratio difference is `r Threshold_TrackingDiff`%. Currently, `r sum(DT_summary$TrackingDiffAboveThresh)` of `r nsubjects` participants have a tracking ratio difference above this threshold. 

```{r}
ggplot(DT_summary, aes(x=TrackingDiff)) +
  geom_histogram(color=title_color, fill="white", size=1.5, binwidth=5) +
  geom_vline(xintercept=Threshold_TrackingDiff, color="red")
```
<br>
<br>

## Histogram: Deviation value (accuracy) L/R difference

Current threshold for a meaningful deviation value difference is `r Threshold_AccuracyDiff` pixels. Currently, `r sum(DT_summary$AccuracyDiffAboveThresh)` of `r nsubjects` participants have a deviation value difference above this threshold. 

```{r}
ggplot(DT_summary, aes(x=AccuracyDiff)) +
  geom_histogram(color=title_color, fill="white", size=1.5, binwidth=5) +
  geom_vline(xintercept=Threshold_AccuracyDiff, color="red")
```
<br>
<br>

***

# Contact 

Contact Heidi Baumgartner (heidibaum@gmail.com) with questions or with feature requests.

Special thanks to Kristen Tummeltshammer, Andrew Lynn, and other members of the DCN Lab at Brown University for help with testing and feature suggestions.

***

